#!/usr/bin/env perl

use strict;
use File::Basename;
use Getopt::Long;
use POSIX;
use Math::Complex;

# these modules should be installed
eval {
   use Parallel::MPI::Simple;
};
if ($@) {
   die "\nERROR: Module Parallel::MPI::Simple is not installed\n\n";
}

eval {
   use Sys::CPU;
};
if ($@) {
   die "\nERROR: Module Sys::CPU is not installed\n\n";
}

eval {
   use IO::Uncompress::Gunzip qw($GunzipError);
};
if ($@) {
   die "\nERROR: Module IO::Uncompress::Gunzip is not installed\n\n";
}

# turn on auto flush
$| = 1;

# use the custom nw algorithm library
my $directory;
BEGIN {$directory = dirname $0;}
use lib "${directory}/../lib";

if (!-e "${directory}/../lib/evaluate.pm") {
   die "\nERROR: ${directory}/../lib/evaluate.pm does not exist\n\n";
}
use evaluate;

# use the library for version control
if (!-e "${directory}/../lib/version.pm") {
   die "\nERROR: ${directory}/../lib/version.pm does not exist\n\n";
}
use version;

my $full_name                     = $0;
my $program_name                  = basename $0;
my $date                          = $version::date;
my $version                       = $version::version;
my $neg_inf                       = -1000000000;
my $outer_length_default_pacbio   = 4000;
my $outer_length_default_illumina = 30;
my $max_array_size                = 50;
my $alphabets                     = "ACGT";
my $max_seq_length                = 50000;
my $max_mpileup_lines             = 1000000;
my $max_read_length               = 50000;
my $max_candidates_default        = 30000;
my $read_length_parallel_default  = 10000;
my $match_gain_default            = 1;
my $mismatch_penalty_default      = -4;
my $gap_extension_penalty_default = -1;
my $gap_opening_penalty_default   = -6;
my $match_gain_pacbio             = 1;
my $mismatch_penalty_pacbio       = -1;
my $gap_extension_penalty_pacbio  = -1;
my $gap_opening_penalty_pacbio    = -1;
my $memory_info_system_file       = "/proc/meminfo";
my $mem_derate                    = 0.8;
my $ng_cutoff                     = 500;
my $read_length_array_size        = 50;
my $max_threads_for_sorting       = 8;
my $samtools                      = "${directory}/samtools/install/bin/samtools";
my $initial_seq_name              = ">";

# categorize bases
# error-free | modified | error-free
# before ec  |          | after ec
#     Y           Y           Y     : cannot happen
#     Y           Y           N     : yyn
#     Y           N           Y     : yny
#     Y           N           N     : cannot happen
#     N           Y           Y     : nyy
#     N           Y           N     : nyn
#     N           N           Y     : cannot happen
#     N           N           N     : nnn
# number of error-free bases before error correction: yyn + yny
# number of erroneous  bases before error correction: nyy + nyn + nnn
# number of error-free bases after  error correction: yny + nyy
# number of erroneous  bases after  error correction: yyn + nyn + nnn
# number of modified bases                          : yyn + nyy + nyn
# number of unmodified bases                        : yny + nnn
# number of correctly modified bases                : nyy
# number of uncorrectly modified bases              : nyn
my $num_yyns_substitution;
my $num_ynys_substitution;
my $num_nyys_substitution;
my $num_nyns_substitution;
my $num_nnns_substitution;

my $num_yyns_insertion;
#my $num_ynys_insertion;
my $num_nyys_insertion;
my $num_nyns_insertion;
my $num_nnns_insertion;

my $num_yyns_deletion;
#my $num_ynys_deletion;
my $num_nyys_deletion;
my $num_nyns_deletion;
my $num_nnns_deletion;

my $num_nyys_substitution_trim;

my $num_nyys_insertion_trim;

my $num_nyys_deletion_trim;

# substition -> deletion
my $num_from_substitution_to_deletion;

my $num_trimmed_bases;

my $num_not_evaluated_substitution;
my $num_not_evaluated_insertion;
my $num_not_evaluated_deletion;

my $org_num_total_bases_percent_similarity;
my $org_num_matched_bases_percent_similarity;

my $cor_num_total_bases_percent_similarity;
my $cor_num_matched_bases_percent_similarity;

my $total_substitutions;
my $total_insertions;
my $total_deletions;

my $total_ref_length1;
my $total_ref_length2;

my $org_ng10_ref1;
my $org_ng30_ref1;
my $org_ng50_ref1;
my $org_ng70_ref1;
my $org_ng90_ref1;

my $org_ng10_ref2;
my $org_ng30_ref2;
my $org_ng50_ref2;
my $org_ng70_ref2;
my $org_ng90_ref2;

my $cor_ng10_ref1;
my $cor_ng30_ref1;
my $cor_ng50_ref1;
my $cor_ng70_ref1;
my $cor_ng90_ref1;

my $cor_ng10_ref2;
my $cor_ng30_ref2;
my $cor_ng50_ref2;
my $cor_ng70_ref2;
my $cor_ng90_ref2;

my $org_total_read_length;
my $org_num_reads;

my $cor_total_read_length;
my $cor_num_reads;

my $max_read_length_real;

my $in_num_threads;

# max length of reads that can be evaluated ini parallel
my $read_length_parallel;

# correct multiplicity - erroneous multiplicity >= 0
my @array_num_diff_err_cor;
# correct multiplicity - erroneous multiplicity >= 0, corrected
my @array_num_diff_err_cor_corrected;
# correct multiplicity - erroneous multiplicity < 0
my @array_num_diff_err_cor_neg;
# correct multiplicity - erroneous multiplicity < 0, corrected
my @array_num_diff_err_cor_corrected_neg;

my @array_coverage;
my @array_coverage_corrected;

my @position_array;
my @position_array_corrected;

my @org_read_length_distribution_array;
my @cor_read_length_distribution_array;

my $header =
"
----------------------------------------------------------------------
PROGRAM: $program_name
CONTACT: Yun Heo (yunheo1\@illinois.edu)
VERSION: $version
DATE   : $date
----------------------------------------------------------------------
\n";

my $usage =
"USAGE: $program_name <ARGUMENTS>

ARGUMENT             DESCRIPTION                   MANDATORY   DEFAULT
----------------------------------------------------------------------
-bam1      <file>    bam file aligned to ref1      N
-bam2      <file>    bam file aligned to ref2      N
-candidate <number>  max number of candidates      N             $max_candidates_default
-corfasta  <file>    corrected single fasta file   N
-corfasta1 <file>    corrected forward fasta file  N
-corfasta2 <file>    corrected reverse fasta file  N
-corfastq  <file>    corrected single fastq file   N
-corfastq1 <file>    corrected forward fastq file  N
-corfastq2 <file>    corrected reverse fastq file  N
-debug     <prefix>  write evaluation detail       N
-detail    <prefix>  perform the detailed analysis N
-endgap              penalize end gaps             N
-gext      <number>  gap extension penalty         N   $gap_extension_penalty_default (PacBio: $gap_extension_penalty_pacbio)
-gopen     <number>  gap opening penalty           N   $gap_opening_penalty_default (PacBio: $gap_opening_penalty_pacbio)
-h                   print help                    N
-location  <file>    error location file           Y
-map       <file>    read map file                 N
-match     <number>  match gain                    N    $match_gain_default (PacBio:  $match_gain_pacbio)
-maxdepth  <number>  max depth for reporting       N                $max_array_size
-mmatch    <number>  mismatch penalty              N   $mismatch_penalty_default (PacBio: $mismatch_penalty_pacbio)
-oneref              load one ref chromosome       N
-orgfasta  <file>    single original fasta file    N
-orgfasta1 <file>    original forward fasta file   N
-orgfasta2 <file>    original reverse fasta file   N
-orgfastq  <file>    original single fastq file    N
-orgfastq1 <file>    original forward fastq file   N
-orgfastq2 <file>    original reverse fastq file   N
-outer     <number>  extra reference base length   N $outer_length_default_illumina (PacBio: $outer_length_default_pacbio)
-pacbio              PacBio reads                  N
-ref1      <file>    1st reference fasta file      Y
-ref2      <file>    2nd reference fasta file      N
-tgs                 evaluate TGS reads            N
-thread    <num>     number of threads for sorting N           # cores
----------------------------------------------------------------------
\n";



######################################################################
# main code
######################################################################

MPI_Init();

#
# variables
#
my $org_fastq_input = 1;
my $cor_fastq_input = 1;
#my @error_count = (0,0,0,0,0);
my $num_yyns_substitution_local = 0;
my $num_ynys_substitution_local = 0;
my $num_nyys_substitution_local = 0;
my $num_nyns_substitution_local = 0;
my $num_nnns_substitution_local = 0;

my $num_yyns_insertion_local = 0;
#my $num_ynys_insertion_local = 0;
my $num_nyys_insertion_local = 0;
my $num_nyns_insertion_local = 0;
my $num_nnns_insertion_local = 0;

my $num_yyns_deletion_local = 0;
#my $num_ynys_deletion_local = 0;
my $num_nyys_deletion_local = 0;
my $num_nyns_deletion_local = 0;
my $num_nnns_deletion_local = 0;

my $num_not_evaluated_substitution_local = 0;
my $num_not_evaluated_insertion_local    = 0;
my $num_not_evaluated_deletion_local     = 0;

my $num_from_substitution_to_deletion_local = 0;

my $num_nyys_substitution_trim_local = 0;

my $num_nyys_insertion_trim_local = 0;

my $num_nyys_deletion_trim_local = 0;

my $org_num_total_bases_percent_similarity_local   = 0;
my $org_num_matched_bases_percent_similarity_local = 0;

my $cor_num_total_bases_percent_similarity_local   = 0;
my $cor_num_matched_bases_percent_similarity_local = 0;

my $total_substitutions_local = 0;
my $total_insertions_local    = 0;
my $total_deletions_local     = 0;

my $num_deletions_5_prime_best = $neg_inf;
my $num_deletions_3_prime_best = $neg_inf;

my $num_substitutions = 0;
my $num_insertions    = 0;
my $num_deletions     = 0;

my $hash_ref_index_1 = 0;
my $hash_ref_index_2 = 0;

my $num_trimmed_bases_local = 0;
my $num_cpus                = Sys::CPU::cpu_count();
my $seq_name                = $initial_seq_name;
my $ref_1_or_2              = 0;
my $ref_1_or_2_prev;

my $seq_name_prev;

my $alignment_score_best;
my $alignment_score_new_best;

my $alignment_best;

my $corrected_read_length;

my $fh_debug_substitution_yyn;
#my $fh_debug_substitution_yny;
#my $fh_debug_substitution_nyy;
my $fh_debug_substitution_nyn;
my $fh_debug_substitution_nnn;

my $fh_debug_insertion_yyn;
my $fh_debug_insertion_nyy;
my $fh_debug_insertion_nyn;
my $fh_debug_insertion_nnn;

my $fh_debug_deletion_yyn;
my $fh_debug_deletion_nyy;
my $fh_debug_deletion_nyn;
my $fh_debug_deletion_nnn;

my $fh_debug_similarity;

# <chromosome> <1-based position in ref> <org> <err> <corrected? Y or N>
my $fh_error_index1;
my $fh_error_index2;
# all the $fh_error_index* files of each core are merged and sorted according to the 1st and 2nd columns
my $fh_error_index_merged_sorted1;
my $fh_error_index_merged_sorted2;

my $in_bam1_file;
my $in_bam2_file;
my $in_location_file;
my $in_ref1_file;
my $in_ref2_file;
my $in_org_fastq_file;
my $in_org_fastq1_file;
my $in_org_fastq2_file;
my $in_org_fasta_file;
my $in_org_fasta1_file;
my $in_org_fasta2_file;
my $in_cor_fastq_file;
my $in_cor_fastq1_file;
my $in_cor_fastq2_file;
my $in_cor_fasta_file;
my $in_cor_fasta1_file;
my $in_cor_fasta2_file;
my $in_match_gain;
my $in_mismatch_penalty;
my $in_gap_opening_penalty;
my $in_gap_extension_penalty;
my $in_debug_prefix;
my $in_detail_prefix;
my $in_max_depth;
my $in_ref_seq_outer_length;
my $in_max_candidates;
my $in_penalize_end_gap = 0;
my $in_pacbio = 0;
my $in_map_file;
my $in_similarity = 0;
my $in_one_ref = 0;

my $help;
my $matrix;
my $is_trimmed;
my $is_paired = 1;

my $num_yyns_substitution_local_prev;
my $num_ynys_substitution_local_prev;
my $num_nyys_substitution_local_prev;
my $num_nyns_substitution_local_prev;
my $num_nnns_substitution_local_prev;

my $num_yyns_insertion_local_prev;
my $num_nyys_insertion_local_prev;
my $num_nyns_insertion_local_prev;
my $num_nnns_insertion_local_prev;

my $num_yyns_deletion_local_prev;
my $num_nyys_deletion_local_prev;
my $num_nyns_deletion_local_prev;
my $num_nnns_deletion_local_prev;

my $num_not_evaluated_substitution_local_prev;
my $num_not_evaluated_insertion_local_prev;
my $num_not_evaluated_deletion_local_prev;

my $num_from_substitution_to_deletion_local_prev;

my $num_nyys_substitution_trim_local_prev;

my $num_nyys_insertion_trim_local_prev;

my $num_nyys_deletion_trim_local_prev;

my $ref_seq_outer_5_prime;
my $ref_seq_outer_3_prime;

my $two_references;

# 1-based
my $start_index;
my $end_index;
my $ref_length_taken;
my $strand;
my $read_name;

my $substitution;
my $insertion;
my $deletion;

my $mpileup_file;

my @score_matrix;

my @position_array_local;
my @corrected_position_array_local;

# c version
my $position_vector_local;
my $corrected_position_vector_local;

my %hash_ref_1;
my %hash_ref_2;
my %hash_ref_name_to_index_1;
my %hash_ref_name_to_index_2;
my %hash_ref_index_to_name_1;
my %hash_ref_index_to_name_2;
my %hash_substitution_org;
my %hash_substitution_err;
my %hash_insertion;
my %hash_deletion;
my %hash_complement;

# mpi variables
my $rank      = MPI_Comm_rank(MPI_COMM_WORLD);
my $num_procs = MPI_Comm_size(MPI_COMM_WORLD);
my $rank_text = sprintf "%0*d", 3, $rank;

#
# print header
#
if ($rank == 0) {
   &print_header;
}

#
# parse arguments
#
&get_memory_info;

#
# parse arguments
#
&parse_args;

#
# compare reads
#
&compare_reads;

MPI_Finalize();

if ($rank == 0) {
   print "\n####################### SUCCESSFULLY COMPLETED #######################\n\n";
}

######################################################################
# end of main code
######################################################################



#----------------------------------------------------------------------
# print_header
#----------------------------------------------------------------------
sub print_header {
   print $header;
}



#----------------------------------------------------------------------
# get_memory_info
#----------------------------------------------------------------------
sub get_memory_info {
   if (-e $memory_info_system_file) {
      my $flag_find = 0;

      open FH_IN, "$memory_info_system_file"
         or die "\nERROR: Cannot open $memory_info_system_file\n\n";

      while (my $line = <FH_IN>) {
         if ($line =~ /MemTotal:\s*(\d+)/) {
            my $mem_size = $1 * 1024;

            $mem_size = $mem_derate * $mem_size;

            # memory per core
            $mem_size = $mem_size / $num_cpus;

            # one matrix size in byte
            # three matrixes * 4 byte integer
            $mem_size = $mem_size / 12.0;

            $read_length_parallel = ceil(sqrt($mem_size));
         }
      }

      close FH_IN;
   }
   else {
      $read_length_parallel = $read_length_parallel_default;
   }
}



#----------------------------------------------------------------------
# parse_args
#----------------------------------------------------------------------
sub parse_args {
   if (@ARGV == 0) {
      if ($rank == 0) {
         print $usage;
      }

      exit;
   }

   if ($rank == 0) {
      print "Parsing arguments\n";
   }

   if (!GetOptions (
                    "bam1=s"      => \$in_bam1_file,
                    "bam2=s"      => \$in_bam2_file,
                    "candidate=i" => \$in_max_candidates,
                    "corfasta=s"  => \$in_cor_fasta_file,
                    "corfasta1=s" => \$in_cor_fasta1_file,
                    "corfasta2=s" => \$in_cor_fasta2_file,
                    "corfastq=s"  => \$in_cor_fastq_file,
                    "corfastq1=s" => \$in_cor_fastq1_file,
                    "corfastq2=s" => \$in_cor_fastq2_file,
                    "debug=s"     => \$in_debug_prefix,
                    "detail=s"    => \$in_detail_prefix,
                    "endgap"      => \$in_penalize_end_gap,
                    "gext=i"      => \$in_gap_extension_penalty,
                    "gopen=i"     => \$in_gap_opening_penalty,
                    "h"           => \$help,
                    "location=s"  => \$in_location_file,
                    "map=s"       => \$in_map_file,
                    "match=i"     => \$in_match_gain,
                    "maxdepth=i"  => \$in_max_depth,
                    "mmatch=i"    => \$in_mismatch_penalty,
                    "oneref"      => \$in_one_ref,
                    "orgfasta=s"  => \$in_org_fasta_file,
                    "orgfasta1=s" => \$in_org_fasta1_file,
                    "orgfasta2=s" => \$in_org_fasta2_file,
                    "orgfastq=s"  => \$in_org_fastq_file,
                    "orgfastq1=s" => \$in_org_fastq1_file,
                    "orgfastq2=s" => \$in_org_fastq2_file,
                    "outer=i"     => \$in_ref_seq_outer_length,
                    "pacbio"      => \$in_pacbio,
                    "ref1=s"      => \$in_ref1_file,
                    "ref2=s"      => \$in_ref2_file,
                    "tgs"         => \$in_similarity,
                    "thread=i"    => \$in_num_threads,
                   )
       or $help) {
      die $usage;
   }

   # check the location file
   if (!defined($in_location_file)) {
      die "\nERROR: An error location file name should be specified\n\n";
   }
   elsif (!-e "$in_location_file") {
      die "\nERROR: $in_location_file does not exist\n\n";
   }

   # ref1
   if (!defined($in_ref1_file)) {
      die "\nERROR: The first genome file name should be specified\n\n";
   }
   elsif (!-e "$in_ref1_file") {
      die "\nERROR: $in_ref1_file does not exist\n\n";
   }

   # ref2
   # $in_ref2_file may not be defined if reads are not generated using pirs
   if (!defined($in_ref2_file)) {
      $two_references = 0;
   }
   # two reference sequences are defined
   else {
      if (!-e "$in_ref2_file") {
         die "\nERROR: $in_ref2_file does not exist\n\n";
      }
      else {
         $two_references = 1;
      }
   }

   # original read input is defined?
   if (!defined($in_org_fastq_file) &&
       !defined($in_org_fasta_file) &&
       !((defined($in_org_fastq1_file)) && (defined($in_org_fastq2_file))) &&
       !((defined($in_org_fasta1_file)) && (defined($in_org_fasta2_file)))
      ) {
         die "\nERROR: Use one of 1) -orgfasta, 2) -orgfastq, 3) -orgfastq1 -orgfastq2, or 4) -orgfasta1 -orgfasta2\n\n";
   }

   # corrected read input is defined?
   if (!defined($in_cor_fastq_file) &&
       !defined($in_cor_fasta_file) &&
       !((defined($in_cor_fastq1_file)) && (defined($in_cor_fastq2_file))) &&
       !((defined($in_cor_fasta1_file)) && (defined($in_cor_fasta2_file)))
      ) {
         die "\nERROR: Use one of 1) -corfasta, 2) -corfastq, 3) -corfastq1 -corfastq2, or 4) -corfasta1 -corfasta2\n\n";
   }

   # original fastq1 is defined?
   if (defined($in_org_fastq1_file)) {
      # check whether fastq1 exists
      if (-e "$in_org_fastq1_file") {
         # fasta* are defined?
         if (defined($in_org_fasta1_file) || defined($in_org_fasta2_file)) {
            die "\nERROR: One between fastq and fasta should be chosen for original reads\n\n";
         }
      }
      else {
         die "\nERROR: $in_org_fastq1_file does not exist\n\n";
      }

      # fastq2 is defined?
      if (defined($in_org_fastq2_file)) {
         unless (-e "$in_org_fastq2_file") {
            die "\nERROR: $in_org_fastq2_file does not exist\n\n";
         }
      }
      else {
         die "\nERROR: The second original fastq file name should be specified\n\n";
      }

      # fastq is defined?
      if (defined($in_org_fastq_file)) {
         die "\nERROR: -orgfastq and -orgfastq1 cannot be used together\n\n";
      }
      # fasta is defined?
      elsif (defined($in_org_fasta_file)) {
         die "\nERROR: -orgfasta and -orgfastq1 cannot be used together\n\n";
      }
   }

   # original fastq is defined?
   if (defined($in_org_fastq_file)) {
      # check whether fastq exists
      unless (-e "$in_org_fastq_file") {
         die "\nERROR: $in_org_fastq_file does not exist\n\n";
      }

      $is_paired = 0;
   }

   # original fasta is defined?
   if (defined($in_org_fasta_file)) {
      # check whether fasta exists
      unless (-e "$in_org_fasta_file") {
         die "\nERROR: $in_org_fasta_file does not exist\n\n";
      }

      $is_paired       = 0;
      $org_fastq_input = 0;
   }

   # original fasta1 is defined?
   if (defined($in_org_fasta1_file)) {
      # check whether fasta1 exists
      if (-e "$in_org_fasta1_file") {
         # fastq* are defined?
         if (defined($in_org_fastq1_file) || defined($in_org_fastq2_file)) {
            die "\nERROR: One between fastq and fasta should be chosen for original reads\n\n";
         }
      }
      else {
         die "\nERROR: $in_org_fasta1_file does not exist\n\n";
      }

      # fasta2 is defined?
      if (defined($in_org_fasta2_file)) {
         if (-e "$in_org_fasta2_file") {
            # input format is fasta
            $org_fastq_input = 0;
         }
         else {
            die "\nERROR: $in_org_fasta2_file does not exist\n\n";
         }
      }
      else {
         die "\nERROR: The second original fasta file name should be specified\n\n";
      }

      # fastq is defined?
      if (defined($in_org_fastq_file)) {
         die "\nERROR: -orgfastq and -orgfasta1 cannot be used together\n\n";
      }
      # fasta is defined?
      elsif (defined($in_org_fasta_file)) {
         die "\nERROR: -orgfasta and -orgfasta1 cannot be used together\n\n";
      }
   }

   # corrected fastq is defined?
   if (defined($in_cor_fastq_file)) {
      if (!defined($in_org_fasta_file) && !defined($in_org_fastq_file)) {
         die "\nERROR: -corfastq should be used with -orgfastq or -orgfasta\n\n";
      }

      # check whether fastq exists
      unless (-e "$in_cor_fastq_file") {
         die "\nERROR: $in_cor_fastq_file does not exist\n\n";
      }
   }

   # corrected fasta is defined?
   if (defined($in_cor_fasta_file)) {
      if (!defined($in_org_fasta_file) && !defined($in_org_fastq_file)) {
         die "\nERROR: -corfasta should be used with -orgfastq or -orgfasta\n\n";
      }

      # check whether fasta exists
      unless (-e "$in_cor_fasta_file") {
         die "\nERROR: $in_cor_fasta_file does not exist\n\n";
      }

      $cor_fastq_input = 0;
   }

   # corrected fastq1 is defined?
   if (defined($in_cor_fastq1_file)) {
      # check whether fastq1 exists
      if (-e "$in_cor_fastq1_file") {
         # fasta* are defined?
         if (defined($in_cor_fasta1_file) || defined($in_cor_fasta2_file)) {
            die "\nERROR: One between fastq and fasta should be chosen for corrected reads\n\n";
         }
      }
      else {
         die "\nERROR: $in_cor_fastq1_file does not exist\n\n";
      }

      # fastq2 is defined?
      if (defined($in_cor_fastq2_file)) {
         unless (-e "$in_cor_fastq2_file") {
            die "\nERROR: $in_cor_fastq2_file does not exist\n\n";
         }
      }
      else {
         die "\nERROR: The second corrected fastq file name should be specified\n\n";
      }

      # fastq is defined?
      if (defined($in_cor_fastq_file)) {
         die "\nERROR: -corfastq and -corfastq1 cannot be used together\n\n";
      }
      # fasta is defined?
      elsif (defined($in_cor_fasta_file)) {
         die "\nERROR: -corfasta and -corfastq1 cannot be used together\n\n";
      }
   }

   # corrected fasta1 is defined?
   if (defined($in_cor_fasta1_file)) {
      # check whether fasta1 exists
      if (-e "$in_cor_fasta1_file") {
         # fastq* are defined?
         if (defined($in_cor_fastq1_file) || defined($in_cor_fastq2_file)) {
            die "\nERROR: One between fastq and fasta should be chosen corrected reads\n\n";
         }
      }
      else {
         die "\nERROR: $in_cor_fasta1_file does not exist\n\n";
      }

      # fasta2 is defined?
      if (defined($in_cor_fasta2_file)) {
         if (-e "$in_cor_fasta2_file") {
            # input format is fasta
            $cor_fastq_input = 0;
         }
         else {
            die "\nERROR: $in_cor_fasta2_file does not exist\n\n";
         }
      }
      else {
         die "\nERROR: The second corrected fasta file name should be specified\n\n";
      }

      # fastq is defined?
      if (defined($in_cor_fastq_file)) {
         die "\nERROR: -corfastq and -corfasta1 cannot be used together\n\n";
      }
      # fasta is defined?
      elsif (defined($in_cor_fasta_file)) {
         die "\nERROR: -corfasta and -corfasta1 cannot be used together\n\n";
      }
   }

   # match gain
   if (defined($in_match_gain)) {
      if ($in_match_gain < 0) {
         die "\nERROR: Match gain should be >= 0\n\n";
      }
   }
   else {
      if ($in_pacbio) {
         $in_match_gain = $match_gain_pacbio;
      }
      else {
         $in_match_gain = $match_gain_default;
      }
   }

   # mismatch penalty
   if (defined($in_mismatch_penalty)) {
      if ($in_mismatch_penalty > 0) {
         die "\nERROR: Mismatch penalty should be <= 0\n\n";
      }
   }
   else {
      if ($in_pacbio) {
         $in_mismatch_penalty = $mismatch_penalty_pacbio;
      }
      else {
         $in_mismatch_penalty = $mismatch_penalty_default;
      }
   }

   # gap extension penalty
   if (defined($in_gap_extension_penalty)) {
      if ($in_gap_extension_penalty > 0) {
         die "\nERROR: Gap extension penalty should be <= 0\n\n";
      }
   }
   else {
      if ($in_pacbio) {
         $in_gap_extension_penalty = $gap_extension_penalty_pacbio;
      }
      else {
         $in_gap_extension_penalty = $gap_extension_penalty_default;
      }
   }

   # gap opening penalty
   if (defined($in_gap_opening_penalty)) {
      if ($in_gap_opening_penalty > 0) {
         die "\nERROR: Gap open penalty should be <= 0\n\n";
      }
   }
   else {
      if ($in_pacbio) {
         $in_gap_opening_penalty = $gap_opening_penalty_pacbio;
      }
      else {
         $in_gap_opening_penalty = $gap_opening_penalty_default;
      }
   }

   # outer length
   if (defined($in_ref_seq_outer_length)) {
      if ($in_ref_seq_outer_length < 0) {
         die "\nERROR: The -outer value should be larger than 0\n\n";
      }
   }
   else {
      if ($in_pacbio) {
         $in_ref_seq_outer_length = $outer_length_default_pacbio;
      }
      else {
         $in_ref_seq_outer_length = $outer_length_default_illumina;
      }
   }

   # max candidates
   if (!defined($in_max_candidates)) {
      $in_max_candidates = $max_candidates_default;
   }

   if (defined($in_debug_prefix)) {
      if ($in_similarity == 1) {
         open $fh_debug_similarity, ">${in_debug_prefix}.similarity.rank-${rank_text}.debug"
            or die "\nERROR: Cannot open ${in_debug_prefix}.similarity.rank-${rank_text}.debug\n\n";
      }
      else {
         open $fh_debug_substitution_yyn, ">${in_debug_prefix}.substitution.yyn.rank-${rank_text}.debug"
            or die "\nERROR: Cannot open ${in_debug_prefix}.substitution.yyn.rank-${rank_text}.debug\n\n";
         #open $fh_debug_substitution_yny, ">${in_debug_prefix}.substitution.yny.rank-${rank_text}.debug"
         #   or die "\nERROR: Cannot open ${in_debug_prefix}.substitution.yny.rank-${rank_text}.debug\n\n";
         #open $fh_debug_substitution_nyy, ">${in_debug_prefix}.substitution.nyy.rank-${rank_text}.debug"
         #   or die "\nERROR: Cannot open ${in_debug_prefix}.substitution.nyy.rank-${rank_text}.debug\n\n";
         open $fh_debug_substitution_nyn, ">${in_debug_prefix}.substitution.nyn.rank-${rank_text}.debug"
            or die "\nERROR: Cannot open ${in_debug_prefix}.substitution.nyn.rank-${rank_text}.debug\n\n";
         open $fh_debug_substitution_nnn, ">${in_debug_prefix}.substitution.nnn.rank-${rank_text}.debug"
            or die "\nERROR: Cannot open ${in_debug_prefix}.substitution.nnn.rank-${rank_text}.debug\n\n";

         open $fh_debug_insertion_yyn, ">${in_debug_prefix}.insertion.yyn.rank-${rank_text}.debug"
            or die "\nERROR: Cannot open ${in_debug_prefix}.insertion.yyn.rank-${rank_text}.debug\n\n";
         open $fh_debug_insertion_nyy, ">${in_debug_prefix}.insertion.nyy.rank-${rank_text}.debug"
            or die "\nERROR: Cannot open ${in_debug_prefix}.insertion.nyy.rank-${rank_text}.debug\n\n";
         open $fh_debug_insertion_nyn, ">${in_debug_prefix}.insertion.nyn.rank-${rank_text}.debug"
            or die "\nERROR: Cannot open ${in_debug_prefix}.insertion.nyn.rank-${rank_text}.debug\n\n";
         open $fh_debug_insertion_nnn, ">${in_debug_prefix}.insertion.nnn.rank-${rank_text}.debug"
            or die "\nERROR: Cannot open ${in_debug_prefix}.insertion.nnn.rank-${rank_text}.debug\n\n";

         open $fh_debug_deletion_yyn, ">${in_debug_prefix}.deletion.yyn.rank-${rank_text}.debug"
            or die "\nERROR: Cannot open ${in_debug_prefix}.deletion.yyn.rank-${rank_text}.debug\n\n";
         open $fh_debug_deletion_nyy, ">${in_debug_prefix}.deletion.nyy.rank-${rank_text}.debug"
            or die "\nERROR: Cannot open ${in_debug_prefix}.deletion.nyy.rank-${rank_text}.debug\n\n";
         open $fh_debug_deletion_nyn, ">${in_debug_prefix}.deletion.nyn.rank-${rank_text}.debug"
            or die "\nERROR: Cannot open ${in_debug_prefix}.deletion.nyn.rank-${rank_text}.debug\n\n";
         open $fh_debug_deletion_nnn, ">${in_debug_prefix}.deletion.nnn.rank-${rank_text}.debug"
            or die "\nERROR: Cannot open ${in_debug_prefix}.deletion.nnn.rank-${rank_text}.debug\n\n";
      }
   }

   # do depth analysis
   if (defined($in_detail_prefix)) {
      # -detail -similarity
      if ($in_similarity) {
         die "\nERROR: -similarity cannot be used with -detail\n\n";
      }

      # -detail -oneref
      if ($in_similarity) {
         die "\nERROR: -oneref cannot be used with -detail\n\n";
      }

      # open
      open $fh_error_index1, ">${in_detail_prefix}.ref-1.rank-${rank_text}"
         or die "\nERROR: Cannot open ${in_detail_prefix}.ref-1.rank-${rank_text}\n\n";
      open $fh_error_index2, ">${in_detail_prefix}.ref-2.rank-${rank_text}"
         or die "\nERROR: Cannot open ${in_detail_prefix}.ref-2.rank-${rank_text}\n\n";

      # bam1 is defined?
      if (defined($in_bam1_file)) {
         # check whether bam1 exists
         unless (-e "$in_bam1_file") {
            die "\nERROR: $in_bam1_file does not exist\n\n";
         }

         # bam2 is defined?
         if (defined($in_bam2_file)) {
            # check whether bam2 exists
            unless (-e "$in_bam2_file") {
               die "\nERROR: $in_bam2_file does not exist\n\n";
            }
         }
         else {
            if ($two_references == 1) {
               die "\nERROR: The second bam file name should be specified\n\n";
            }
         }
      }
      else {
         die "\nERROR: The first bam file name should be specified\n\n";
      }

      $mpileup_file = ${in_detail_prefix} . ".mpileup";
   }

   # map file
   if (defined($in_map_file)) {
      # check whether the map file exists
      unless (-e "$in_map_file") {
         die "\nERROR: $in_map_file does not exist\n\n";
      }

      unless ($in_similarity) {
         die "\nERROR: -map should always be used with -similarity\n\n";
      }
   }

   # maximum depth reported
   if (!defined($in_max_depth)) {
      $in_max_depth = $max_array_size;
   }
   elsif ($in_max_depth <= 0) {
      die "\nERROR: The value of -maxdepth should be > 0\n\n";
   }

   # set the hash for reverse complement
   # these values are needed only for the detailed anlyses
   # reverse complement has already been applied
   # to the error information in the location file
   $hash_complement{"A"} = "T";
   $hash_complement{"C"} = "G";
   $hash_complement{"G"} = "C";
   $hash_complement{"T"} = "A";

   # number of threads
   if (defined($in_num_threads)) {
      if ($in_num_threads > $max_threads_for_sorting) {
         print "     \nWARNING: Using over $max_threads_for_sorting threads for sorting degrades performance; $max_threads_for_sorting threads will be used\n\n";
         $in_num_threads = $max_threads_for_sorting;
      }
   }
   else {
      if (Sys::CPU::cpu_count() > $max_threads_for_sorting) {
         $in_num_threads = $max_threads_for_sorting;
      }
      else {
         $in_num_threads = Sys::CPU::cpu_count();
      }
   }

   if ($rank == 0) {
      print "     Code                    : $full_name\n";
      print "     Number of processors    : $num_procs\n";

      if (defined($in_org_fastq_file)) {
         print "     Original fastq          : $in_org_fastq_file\n";
      }
      elsif (defined($in_org_fasta_file)) {
         print "     Original fasta          : $in_org_fasta_file\n";
      }
      elsif (defined($in_org_fastq1_file)) {
         print "     Original fastq 1st      : $in_org_fastq1_file\n";
         print "     Original fastq 2nd      : $in_org_fastq2_file\n";
      }
      else {
         print "     Original fasta 1st      : $in_org_fasta1_file\n";
         print "     Original fasta 2nd      : $in_org_fasta2_file\n";
      }

      if (defined($in_cor_fastq_file)) {
         print "     Corrected fastq         : $in_cor_fastq_file\n";
      }
      elsif (defined($in_cor_fasta_file)) {
         print "     Corrected fasta         : $in_cor_fasta_file\n";
      }
      elsif (defined($in_cor_fastq1_file)) {
         print "     Corrected fastq 1st     : $in_cor_fastq1_file\n";
         print "     Corrected fastq 2nd     : $in_cor_fastq2_file\n";
      }
      else {
         print "     Corrected fasta 1st     : $in_cor_fasta1_file\n";
         print "     Corrected fasta 2nd     : $in_cor_fasta2_file\n";
      }

      print "     Reference fasta 1st     : $in_ref1_file\n";
      if (defined($in_ref2_file)) {
         print "     Reference fasta 2nd     : $in_ref2_file\n";
      }

      print "     Location file           : $in_location_file\n";
      print "     Max parallel read length: $read_length_parallel\n";
      print "     Match gain              : $in_match_gain\n";
      print "     Mismatatch penalty      : $in_mismatch_penalty\n";
      print "     Gap opening penalty     : $in_gap_opening_penalty\n";
      print "     Gap extension penalty   : $in_gap_extension_penalty\n";

      if ($in_similarity == 1) {
         print "     Evaluation method       : Percent similarity\n";

         if (defined($in_map_file)) {
            print "     Mapping file            : $in_map_file\n";
         }
      }
      else {
         print "     Evaluation method       : Counting errors\n";
      }

      if (defined($in_detail_prefix)) {
         print "     Bam file 1st            : $in_bam1_file\n";

         if (defined($in_bam2_file)) {
            print "     Bam file 2nd            : $in_bam2_file\n";
         }
      }

      if (defined($in_debug_prefix)) {
         print "     Debug files             : ${in_debug_prefix}*\n";
      }

      print "     Parsing argumetns: done\n";
   }
}



#----------------------------------------------------------------------
# read_ref_sequence
#----------------------------------------------------------------------
sub read_ref_sequence {
   # arguemnts
   # 1st($_[0]): reference sequence fasta
   # 2nd($_[1]): %hash_ref_[12]
   # 3rd($_[2]): %hash_ref_name_to_index
   # 4th($_[3]): %hash_ref_index_to_name
   # 5th($_[4]): $hash_ref_index
   # 6th($_[5]): $total_ref_length[12]

   # open files
   my $fh_in;
   open $fh_in, "$_[0]"
      or die "\nERROR: Cannot open $_[0]\n\n";

   my $seq_name_reading      = "";
   my $seq_name_reading_tmp  = "";
   my $buffer                = "";

   # initialize total length
   $_[5] = 0;

   while (my $line = <$fh_in>) {
      chomp $line;

      if ($line =~ /^>(\S+)/) {
         $seq_name_reading_tmp = $1;

         # update the hash table
         # not the first sequence
         if ($seq_name_reading ne "") {
            if (length($buffer) > 0) {
               # if the oneref option is used
               # chromosomes are loaded only when they are needed
               if ($in_one_ref == 0) {
                  # %hash_ref_[12]
                  $_[1]{$seq_name_reading} = $buffer;
               }

               # update total length
               $_[5] += length($buffer);

               # %hash_ref_name_to_index
               $_[4]++;
               $_[2]{$seq_name_reading} = $_[4];

               # %hash_ref_index_to_name
               $_[3]{$_[4]} = $seq_name_reading;
            }
            else {
               die "\nERROR: Buffer is empty\n\n";
            }
         }

         $seq_name_reading = $seq_name_reading_tmp;
         $buffer           = "";
      }
      elsif ($line =~ /^$/) {
      }
      else {
         $line = uc $line;
         $buffer = $buffer . $line;
      }
   }

   if (length($buffer) > 0) {
      unless(defined($_[1]{$seq_name_reading})) {
         # if the oneref option is used
         # chromosomes are loaded only when they are needed
         if ($in_one_ref == 0) {
            # %hash_ref_[12]
            $_[1]{$seq_name_reading} = $buffer;
         }

         # update total length
         $_[5] += length($buffer);

         # %hash_ref_name_to_index
         $_[4]++;
         $_[2]{$seq_name_reading} = $_[4];

         # %hash_ref_index_to_name
         $_[3]{$_[4]} = $seq_name_reading;
      }
      else {
         die "\nERROR: Same sequence name\n\n";
      }
   }

   close $fh_in;
}



#----------------------------------------------------------------------
# compare_reads
#----------------------------------------------------------------------
sub compare_reads {
   if ($rank == 0) {
      print "\nComparing reads\n";
   }

   # construct and initialize the c arrays
   $position_vector_local           = evaluate::new_intp($max_read_length);
   $corrected_position_vector_local = evaluate::new_intp($max_read_length);

   for (my $i = 0; $i <= $max_read_length; $i++) {
      evaluate::intp_setitem($position_vector_local,           $i, 0);
      evaluate::intp_setitem($corrected_position_vector_local, $i, 0);
   }

   # construct a hash table using the new reference
   &read_ref_sequence($in_ref1_file, \%hash_ref_1, \%hash_ref_name_to_index_1, \%hash_ref_index_to_name_1, $hash_ref_index_1, $total_ref_length1);

   if ($two_references == 1) {
      &read_ref_sequence($in_ref2_file, \%hash_ref_2, \%hash_ref_name_to_index_2, \%hash_ref_index_to_name_2, $hash_ref_index_2, $total_ref_length2);
   }

   my $fh_location;
   my $fh_map;
   my $fh_org_read1;
   my $fh_org_read2;
   my $fh_cor_read1;
   my $fh_cor_read2;
   my $line_tmp;

   #**********************************************************************
   # evaluate reads that are <= $read_length_parallel
   #**********************************************************************
   # open the input location file
   open $fh_location, "$in_location_file"
      or die "\nERROR: Cannot open $in_location_file\n\n";

   # open the map file
   if (defined($in_map_file)) {
      open $fh_map, "$in_map_file"
         or die "\nERROR: Cannot open $in_map_file\n\n";
   }

   # open original read files
   if ($is_paired) {
      if ($org_fastq_input == 1) {
         if ($in_org_fastq1_file =~ /\.gz$/) {
            $fh_org_read1 = IO::Uncompress::Gunzip->new($in_org_fastq1_file)
               or die "\nERROR: Cannot open $in_org_fastq1_file\n\n"
         }
         else {
            open $fh_org_read1, "$in_org_fastq1_file"
               or die "\nERROR: Cannot open $in_org_fastq1_file\n\n";
         }

         if ($in_org_fastq2_file =~ /\.gz$/) {
            $fh_org_read2 = IO::Uncompress::Gunzip->new($in_org_fastq2_file)
               or die "\nERROR: Cannot open $in_org_fastq2_file\n\n"
         }
         else {
            open $fh_org_read2, "$in_org_fastq2_file"
               or die "\nERROR: Cannot open $in_org_fastq2_file\n\n";
         }
      }
      else {
         if ($in_org_fasta1_file =~ /\.gz$/) {
            $fh_org_read1 = IO::Uncompress::Gunzip->new($in_org_fasta1_file)
               or die "\nERROR: Cannot open $in_org_fasta1_file\n\n"
         }
         else {
            open $fh_org_read1, "$in_org_fasta1_file"
               or die "\nERROR: Cannot open $in_org_fasta1_file\n\n";
         }

         if ($in_org_fasta2_file =~ /\.gz$/) {
            $fh_org_read2 = IO::Uncompress::Gunzip->new($in_org_fasta2_file)
               or die "\nERROR: Cannot open $in_org_fasta2_file\n\n"
         }
         else {
            open $fh_org_read2, "$in_org_fasta2_file"
               or die "\nERROR: Cannot open $in_org_fasta2_file\n\n";
         }
      }
   }
   else {
      if ($org_fastq_input == 1) {
         if ($in_org_fastq_file =~ /\.gz$/) {
            $fh_org_read1 = IO::Uncompress::Gunzip->new($in_org_fastq_file)
               or die "\nERROR: Cannot open $in_org_fastq_file\n\n"
         }
         else {
            open $fh_org_read1, "$in_org_fastq_file"
               or die "\nERROR: Cannot open $in_org_fastq_file\n\n";
         }
      }
      else {
         if ($in_org_fasta_file =~ /\.gz$/) {
            $fh_org_read1 = IO::Uncompress::Gunzip->new($in_org_fasta_file)
               or die "\nERROR: Cannot open $in_org_fasta_file\n\n"
         }
         else {
            open $fh_org_read1, "$in_org_fasta_file"
               or die "\nERROR: Cannot open $in_org_fasta_file\n\n";
         }
      }
   }

   # open corrected read files
   if ($is_paired) {
      if ($cor_fastq_input == 1) {
         if ($in_cor_fastq1_file =~ /\.gz$/) {
            $fh_cor_read1 = IO::Uncompress::Gunzip->new($in_cor_fastq1_file)
               or die "\nERROR: Cannot open $in_cor_fastq1_file\n\n"
         }
         else {
            open $fh_cor_read1, "$in_cor_fastq1_file"
               or die "\nERROR: Cannot open $in_cor_fastq1_file\n\n";
         }

         if ($in_cor_fastq2_file =~ /\.gz$/) {
            $fh_cor_read2 = IO::Uncompress::Gunzip->new($in_cor_fastq2_file)
               or die "\nERROR: Cannot open $in_cor_fastq2_file\n\n"
         }
         else {
            open $fh_cor_read2, "$in_cor_fastq2_file"
               or die "\nERROR: Cannot open $in_cor_fastq2_file\n\n";
         }
      }
      else {
         if ($in_cor_fasta1_file =~ /\.gz$/) {
            $fh_cor_read1 = IO::Uncompress::Gunzip->new($in_cor_fasta1_file)
               or die "\nERROR: Cannot open $in_cor_fasta1_file\n\n"
         }
         else {
            open $fh_cor_read1, "$in_cor_fasta1_file"
               or die "\nERROR: Cannot open $in_cor_fasta1_file\n\n";
         }

         if ($in_cor_fasta2_file =~ /\.gz$/) {
            $fh_cor_read2 = IO::Uncompress::Gunzip->new($in_cor_fasta2_file)
               or die "\nERROR: Cannot open $in_cor_fasta2_file\n\n"
         }
         else {
            open $fh_cor_read2, "$in_cor_fasta2_file"
               or die "\nERROR: Cannot open $in_cor_fasta2_file\n\n";
         }
      }
   }
   else {
      if ($cor_fastq_input == 1) {
         if ($in_cor_fastq_file =~ /\.gz$/) {
            $fh_cor_read1 = IO::Uncompress::Gunzip->new($in_cor_fastq_file)
               or die "\nERROR: Cannot open $in_cor_fastq_file\n\n"
         }
         else {
            open $fh_cor_read1, "$in_cor_fastq_file"
               or die "\nERROR: Cannot open $in_cor_fastq_file\n\n";
         }
      }
      else {
         if ($in_cor_fasta_file =~ /\.gz$/) {
            $fh_cor_read1 = IO::Uncompress::Gunzip->new($in_cor_fasta_file)
               or die "\nERROR: Cannot open $in_cor_fasta_file\n\n"
         }
         else {
            open $fh_cor_read1, "$in_cor_fasta_file"
               or die "\nERROR: Cannot open $in_cor_fasta_file\n\n";
         }
      }
   }

   # read each file
   my $read_length;
   my $trim_length;
   my $num_lines = 0;
   my $line_map;
   my $read_name_map;
   my $occurrence_map;

   while (my $line_location = <$fh_location>) {
      my $line_org_header1;
      my $line_org_header2;
      my $line_org_read1;
      my $line_org_read2;

      my $line_cor_header1;
      my $line_cor_header2;
      my $line_cor_read1;
      my $line_cor_read2;

      my $read_length_check;

      # read the map file
      if (defined($in_map_file)) {
         $line_map = <$fh_map>;

         if ($line_map =~ /^(\S+)\s+(\d+)/) {
            $read_name_map  = $1;
            $occurrence_map = $2;
         }
         else {
            die "\nERROR: Wrong map line $line_map\n";
         }
      }
      # if a map file is not used
      else {
         $occurrence_map = 1;
      }

      #
      # lines that should be processed in this core
      #
      if (($num_lines % $num_procs) == $rank) {
         #----------------------------------------------------------------------
         # forward read
         #----------------------------------------------------------------------
         # <read name> <ref 1 or 2> <ref name> <strand> <start index> <read length> <substitutions> <insertions> <deletions>
         if ($line_location =~ /^\S+\s+[12]\s+\S+\s+[\+\-]\s+[\d\-]+\s+(\d+)\s+(\S+)\s+(\S+)\s+(\S+)/) {
            $read_length_check = $1;

            &parse_errors($1, $2, $3, $4);
         }
         # skip this line
         elsif ($line_location =~ /^\S+\s+N\/A\s*$/) {
            $read_length_check = $read_length_parallel + 1;
         }
         else {
            die "\nERROR: $line_location\n";
         }

         # read length is not too long: process it
         if ($read_length_check <= $read_length_parallel) {
            # read header and sequence lines of original reads
            $line_org_header1 = <$fh_org_read1> ;
            unless (defined($line_org_header1)) {
               die "\nERROR: Number of lines in the location file is not matched with that in the original read\n\n";
            }

            $line_org_read1 = <$fh_org_read1>;
            $line_org_read1 = uc $line_org_read1;

            # consume unnecessary lines
            if ($org_fastq_input == 1) {
               $line_tmp = <$fh_org_read1>;
               $line_tmp = <$fh_org_read1>;
            }

            chomp $line_org_header1;
            chomp $line_org_read1;

            # check original read lines
            if ($org_fastq_input == 1) {
               unless ($line_org_header1 =~ /^\@/) {
                  die "\nERROR: $line_org_header1\n";
               }
            }
            else {
               unless ($line_org_header1 =~ /^\>/) {
                  die "\nERROR: $line_org_header1\n";
               }
            }

            # there could be multiple corrected reads for one original read
            # this is because some pacbio error correction tools split reads into pieces
            for (my $it_map = 0; $it_map < $occurrence_map; $it_map++) {
               # read header and sequence lines of corrected reads
               $line_cor_header1 = <$fh_cor_read1>;
               unless (defined($line_cor_header1)) {
                  die "\nERROR: Number of lines in the location file is not matched with that in the corrected read\n\n";
               }

               $line_cor_read1 = <$fh_cor_read1>;
               $line_cor_read1 = uc $line_cor_read1;

               # consume unnecessary lines
               if ($cor_fastq_input == 1) {
                  $line_tmp = <$fh_cor_read1>;
                  $line_tmp = <$fh_cor_read1>;
               }

               chomp $line_cor_header1;
               chomp $line_cor_read1;

               # check corrected read lines
               if ($cor_fastq_input == 1) {
                  unless ($line_cor_header1 =~ /^\@/) {
                     die "\nERROR: $line_cor_header1\n";
                  }
               }
               else {
                  unless ($line_cor_header1 =~ /^\>/) {
                     die "\nERROR: $line_cor_header1\n";
                  }
               }

               # count the number of trimmed bases
               $read_length           = length($line_org_read1);
               $corrected_read_length = length($line_cor_read1);

               $trim_length = $read_length - $corrected_read_length;
               if ($trim_length > 0) {
                  $is_trimmed = 1;
                  $num_trimmed_bases_local += $trim_length;
               }
               else {
                  $is_trimmed = 0;
               }

               # record current values
               if ($in_similarity == 0) {
                  $num_yyns_substitution_local_prev = $num_yyns_substitution_local;
                  $num_ynys_substitution_local_prev = $num_ynys_substitution_local;
                  $num_nyys_substitution_local_prev = $num_nyys_substitution_local;
                  $num_nyns_substitution_local_prev = $num_nyns_substitution_local;
                  $num_nnns_substitution_local_prev = $num_nnns_substitution_local;

                  $num_yyns_insertion_local_prev = $num_yyns_insertion_local;
                  $num_nyys_insertion_local_prev = $num_nyys_insertion_local;
                  $num_nyns_insertion_local_prev = $num_nyns_insertion_local;
                  $num_nnns_insertion_local_prev = $num_nnns_insertion_local;

                  $num_yyns_deletion_local_prev = $num_yyns_deletion_local;
                  $num_nyys_deletion_local_prev = $num_nyys_deletion_local;
                  $num_nyns_deletion_local_prev = $num_nyns_deletion_local;
                  $num_nnns_deletion_local_prev = $num_nnns_deletion_local;

                  $num_not_evaluated_substitution_local_prev = $num_not_evaluated_substitution_local;
                  $num_not_evaluated_insertion_local_prev    = $num_not_evaluated_insertion_local;
                  $num_not_evaluated_deletion_local_prev     = $num_not_evaluated_deletion_local;

                  $num_from_substitution_to_deletion_local_prev = $num_from_substitution_to_deletion_local;

                  $num_nyys_substitution_trim_local_prev = $num_nyys_substitution_trim_local;

                  $num_nyys_insertion_trim_local_prev = $num_nyys_insertion_trim_local;

                  $num_nyys_deletion_trim_local_prev = $num_nyys_deletion_trim_local;
               }

               #
               # compare the first read
               #
               &compare_one_read($line_location, $line_cor_read1, $read_length, $line_org_read1);
             
               if ($in_similarity == 0) {
                  # check the number of processed errors
                  $total_substitutions_local += $num_substitutions;
                  $total_insertions_local    += $num_insertions;
                  $total_deletions_local     += $num_deletions;

                  # check the number of processed errors
                  # substitution
                  if ($num_substitutions > 0) {
                     if ($num_substitutions !=
                         (($num_nyys_substitution_local - $num_nyys_substitution_local_prev) +
                          ($num_nyns_substitution_local - $num_nyns_substitution_local_prev) +
                          ($num_nnns_substitution_local - $num_nnns_substitution_local_prev) +
                          ($num_from_substitution_to_deletion_local - $num_from_substitution_to_deletion_local_prev) +
                          ($num_nyys_substitution_trim_local - $num_nyys_substitution_trim_local_prev) +
                          ($num_not_evaluated_substitution_local - $num_not_evaluated_substitution_local_prev))) {
                        printf "\nERROR: $line_org_header1\nS TOTAL(%d) vs NYY /wo TRIM(%d) + NYN(%d) + NNN(%d) + NYY TRIM(%d) + NOT EVAL(%d)\n\n",
                           $num_substitutions,
                           $num_nyys_substitution_local - $num_nyys_substitution_local_prev,
                           $num_nyns_substitution_local - $num_nyns_substitution_local_prev,
                           $num_nnns_substitution_local - $num_nnns_substitution_local_prev,
                           $num_nyys_substitution_trim_local - $num_nyys_substitution_trim_local_prev,
                           $num_not_evaluated_substitution_local - $num_not_evaluated_substitution_local_prev;
                        print "$alignment_best\n";
                        exit;
                     }
                  }

                  # insertion
                  if ($num_insertions > 0) {
                     if ($num_insertions !=
                         (($num_nyys_insertion_local - $num_nyys_insertion_local_prev) +
                          ($num_nyns_insertion_local - $num_nyns_insertion_local_prev) +
                          ($num_nnns_insertion_local - $num_nnns_insertion_local_prev) +
                          ($num_nyys_insertion_trim_local - $num_nyys_insertion_trim_local_prev) +
                          ($num_not_evaluated_insertion_local - $num_not_evaluated_insertion_local_prev))) {
                        printf "\nERROR: $line_org_header1\nI TOTAL(%d) vs NYY /wo TRIM(%d) + NYN(%d) + NNN(%d) + NYY TRIM(%d) + NOT EVAL(%d)\n\n",
                           $num_insertions,
                           $num_nyys_insertion_local - $num_nyys_insertion_local_prev,
                           $num_nyns_insertion_local - $num_nyns_insertion_local_prev,
                           $num_nnns_insertion_local - $num_nnns_insertion_local_prev,
                           $num_nyys_insertion_trim_local - $num_nyys_insertion_trim_local_prev,
                           $num_not_evaluated_insertion_local - $num_not_evaluated_insertion_local_prev;
                        print "$alignment_best\n";
                        exit;
                     }
                  }

                  # deletion
                  if ($num_deletions > 0) {
                     if ($num_deletions !=
                         (($num_nyys_deletion_local - $num_nyys_deletion_local_prev) +
                          ($num_nyns_deletion_local - $num_nyns_deletion_local_prev) +
                          ($num_nnns_deletion_local - $num_nnns_deletion_local_prev) +
                          ($num_nyys_deletion_trim_local - $num_nyys_deletion_trim_local_prev) +
                          ($num_not_evaluated_deletion_local - $num_not_evaluated_deletion_local_prev))) {
                        printf "\nERROR: $line_org_header1\nD TOTAL(%d) vs NYY /wo TRIM(%d) + NYN(%d) + NNN(%d) + NYY TRIM(%d) + NOT EVAL(%d)\n\n",
                           $num_deletions,
                           $num_nyys_deletion_local - $num_nyys_deletion_local_prev,
                           $num_nyns_deletion_local - $num_nyns_deletion_local_prev,
                           $num_nnns_deletion_local - $num_nnns_deletion_local_prev,
                           $num_nyys_deletion_trim_local - $num_nyys_deletion_trim_local_prev,
                           $num_not_evaluated_deletion_local - $num_not_evaluated_deletion_local_prev;
                        print "$alignment_best\n";
                        exit;
                     }
                  }
               }
            }
         }
         # read length is too long: skip this
         # or N/A in the location file
         else {
            # skip unnecessary reads
            $line_tmp = <$fh_org_read1> ;
            $line_tmp = <$fh_org_read1>;

            $trim_length = length($line_tmp);

            if ($org_fastq_input == 1) {
               $line_tmp = <$fh_org_read1>;
               $line_tmp = <$fh_org_read1>;
            }

            # the number of corresponding corrected reads might be over one
            for (my $it_map = 0; $it_map < $occurrence_map; $it_map++) {
               $line_tmp = <$fh_cor_read1>;
               $line_tmp = <$fh_cor_read1>;

               $trim_length -= length($line_tmp);

               if ($trim_length > 0) {
                  if (!defined($in_map_file)) {
                     $num_trimmed_bases_local += $trim_length;
                  }
               }

               if ($cor_fastq_input == 1) {
                  $line_tmp = <$fh_cor_read1>;
                  $line_tmp = <$fh_cor_read1>;
               }
            }
         }
         #
         # end of forward read
         #

         #----------------------------------------------------------------------
         # reverse read
         #----------------------------------------------------------------------
         if ($is_paired) {
            # take a new location line
            $line_location = <$fh_location>;

            # <read name> <ref 1 or 2> <ref name> <strand> <start index> <read length> <substitutions> <insertions> <deletions>
            if ($line_location =~ /^\S+\s+[12]\s+\S+\s+[\+\-]\s+[\d\-]+\s+(\d+)\s+(\S+)\s+(\S+)\s+(\S+)/) {
               $read_length_check = $1;

               &parse_errors($1, $2, $3, $4);
            }
            # skip this line
            elsif ($line_location =~ /^\S+\s+N\/A\s*$/) {
               $read_length_check = $read_length_parallel + 1;
            }
            else {
               die "\nERROR: $line_location\n";
            }

            # read length is not too long: process it
            if ($read_length_check <= $read_length_parallel) {
               unless (defined($line_location)) {
                  die "\nERROR: The number of reads in $in_location_file is odd\n\n";
               }
               else {
                  # read header and sequence lines of original reads
                  $line_org_header2 = <$fh_org_read2>;
                  unless (defined($line_org_header2)) {
                     die "\nERROR: Number of lines in the location file is not matched with that in the original read\n\n";
                  }

                  $line_org_read2 = <$fh_org_read2>;
                  $line_org_read2 = uc $line_org_read2;

                  # consume unnecessary lines
                  if ($org_fastq_input == 1) {
                     $line_tmp = <$fh_org_read2>;
                     $line_tmp = <$fh_org_read2>;
                  }

                  chomp $line_org_header2;
                  chomp $line_org_read2;

                  # check original read lines
                  if ($org_fastq_input == 1) {
                     unless ($line_org_header2 =~ /^\@/) {
                        die "\nERROR: $line_org_read2\n";
                     }
                  }
                  else {
                     unless ($line_org_header2 =~ /^\>/) {
                        die "\nERROR: $line_org_read2\n";
                     }
                  }

                  # there could be multiple corrected reads for one original read
                  # this is because some pacbio error correction tools split reads into pieces
                  for (my $it_map = 0; $it_map < $occurrence_map; $it_map++) {
                     # read header and sequence lines of corrected reads
                     $line_cor_header2 = <$fh_cor_read2>;
                     unless (defined($line_cor_header2)) {
                        die "\nERROR: Number of lines in the location file is not matched with that in the corrected read\n\n";
                     }

                     $line_cor_read2 = <$fh_cor_read2>;
                     $line_cor_read2 = uc $line_cor_read2;

                     # consume unnecessary lines
                     if ($cor_fastq_input == 1) {
                        $line_tmp = <$fh_cor_read2>;
                        $line_tmp = <$fh_cor_read2>;
                     }

                     chomp $line_cor_header2;
                     chomp $line_cor_read2;

                     # check corrected read lines
                     if ($cor_fastq_input == 1) {
                        unless ($line_cor_header2 =~ /^\@/) {
                           die "\nERROR: $line_cor_read2\n";
                        }
                     }
                     else {
                        unless ($line_cor_header2 =~ /^\>/) {
                           die "\nERROR: $line_cor_read2\n";
                        }
                     }

                     # count the number of trimmed bases
                     $read_length           = length($line_org_read2);
                     $corrected_read_length = length($line_cor_read2);

                     $trim_length = $read_length - $corrected_read_length;
                     if ($trim_length > 0) {
                        $is_trimmed = 1;
                        $num_trimmed_bases_local += $trim_length;
                     }
                     else {
                        $is_trimmed = 0;
                     }

                     # record current values
                     if ($in_similarity == 0) {
                        $num_yyns_substitution_local_prev = $num_yyns_substitution_local;
                        $num_ynys_substitution_local_prev = $num_ynys_substitution_local;
                        $num_nyys_substitution_local_prev = $num_nyys_substitution_local;
                        $num_nyns_substitution_local_prev = $num_nyns_substitution_local;
                        $num_nnns_substitution_local_prev = $num_nnns_substitution_local;

                        $num_yyns_insertion_local_prev = $num_yyns_insertion_local;
                        $num_nyys_insertion_local_prev = $num_nyys_insertion_local;
                        $num_nyns_insertion_local_prev = $num_nyns_insertion_local;
                        $num_nnns_insertion_local_prev = $num_nnns_insertion_local;

                        $num_yyns_deletion_local_prev = $num_yyns_deletion_local;
                        $num_nyys_deletion_local_prev = $num_nyys_deletion_local;
                        $num_nyns_deletion_local_prev = $num_nyns_deletion_local;
                        $num_nnns_deletion_local_prev = $num_nnns_deletion_local;

                        $num_not_evaluated_substitution_local_prev = $num_not_evaluated_substitution_local;
                        $num_not_evaluated_insertion_local_prev    = $num_not_evaluated_insertion_local;
                        $num_not_evaluated_deletion_local_prev     = $num_not_evaluated_deletion_local;

                        $num_from_substitution_to_deletion_local_prev = $num_from_substitution_to_deletion_local;

                        $num_nyys_substitution_trim_local_prev = $num_nyys_substitution_trim_local;

                        $num_nyys_insertion_trim_local_prev = $num_nyys_insertion_trim_local;

                        $num_nyys_deletion_trim_local_prev = $num_nyys_deletion_trim_local;
                     }

                     #
                     # compare the second read
                     #
                     &compare_one_read($line_location, $line_cor_read2, $read_length, $line_org_read2);

                     if ($in_similarity == 0) {
                        # check the number of processed errors
                        $total_substitutions_local += $num_substitutions;
                        $total_insertions_local    += $num_insertions;
                        $total_deletions_local     += $num_deletions;

                        # check the number of processed errors
                        # substitution
                        if ($num_substitutions > 0) {
                           if ($num_substitutions !=
                               (($num_nyys_substitution_local - $num_nyys_substitution_local_prev) +
                                ($num_nyns_substitution_local - $num_nyns_substitution_local_prev) +
                                ($num_nnns_substitution_local - $num_nnns_substitution_local_prev) +
                                ($num_from_substitution_to_deletion_local - $num_from_substitution_to_deletion_local_prev) +
                                ($num_nyys_substitution_trim_local - $num_nyys_substitution_trim_local_prev) +
                                ($num_not_evaluated_substitution_local - $num_not_evaluated_substitution_local_prev))) {
                              printf "\nERROR: $line_org_header2\nS TOTAL(%d) vs NYY /wo TRIM(%d) + NYN(%d) + NNN(%d) + NYY TRIM(%d) + NOT EVAL(%d)\n\n",
                                 $num_substitutions,
                                 $num_nyys_substitution_local - $num_nyys_substitution_local_prev,
                                 $num_nyns_substitution_local - $num_nyns_substitution_local_prev,
                                 $num_nnns_substitution_local - $num_nnns_substitution_local_prev,
                                 $num_nyys_substitution_trim_local - $num_nyys_substitution_trim_local_prev,
                                 $num_not_evaluated_substitution_local - $num_not_evaluated_substitution_local_prev;
                              print "$alignment_best\n";
                              exit;
                           }
                        }

                        # insertion
                        if ($num_insertions > 0) {
                           if ($num_insertions !=
                               (($num_nyys_insertion_local - $num_nyys_insertion_local_prev) +
                                ($num_nyns_insertion_local - $num_nyns_insertion_local_prev) +
                                ($num_nnns_insertion_local - $num_nnns_insertion_local_prev) +
                                ($num_nyys_insertion_trim_local - $num_nyys_insertion_trim_local_prev) + 
                                ($num_not_evaluated_insertion_local - $num_not_evaluated_insertion_local_prev))) {
                              printf "\nERROR: $line_org_header2\nI TOTAL(%d) vs NYY /wo TRIM(%d) + NYN(%d) + NNN(%d) + NYY TRIM(%d) + NOT EVAL(%d)\n\n",
                                 $num_insertions,
                                 $num_nyys_insertion_local - $num_nyys_insertion_local_prev,
                                 $num_nyns_insertion_local - $num_nyns_insertion_local_prev,
                                 $num_nnns_insertion_local - $num_nnns_insertion_local_prev,
                                 $num_nyys_insertion_trim_local - $num_nyys_insertion_trim_local_prev,
                                 $num_not_evaluated_insertion_local - $num_not_evaluated_insertion_local_prev;
                              print "$alignment_best\n";
                              exit;
                           }
                        }

                        # deletion
                        if ($num_deletions > 0) {
                           if ($num_deletions !=
                               (($num_nyys_deletion_local - $num_nyys_deletion_local_prev) +
                                ($num_nyns_deletion_local - $num_nyns_deletion_local_prev) +
                                ($num_nnns_deletion_local - $num_nnns_deletion_local_prev) +
                                ($num_nyys_deletion_trim_local - $num_nyys_deletion_trim_local_prev) +
                                ($num_not_evaluated_deletion_local - $num_not_evaluated_deletion_local_prev))) {
                              printf "\nERROR: $line_org_header2\nD TOTAL(%d) vs NYY /wo TRIM(%d) + NYN(%d) + NNN(%d) + NYY TRIM(%d) + NOT EVAL(%d)\n\n",
                                 $num_deletions,
                                 $num_nyys_deletion_local - $num_nyys_deletion_local_prev,
                                 $num_nyns_deletion_local - $num_nyns_deletion_local_prev,
                                 $num_nnns_deletion_local - $num_nnns_deletion_local_prev,
                                 $num_nyys_deletion_trim_local - $num_nyys_deletion_trim_local_prev,
                                 $num_not_evaluated_deletion_local - $num_not_evaluated_deletion_local_prev;
                              print "$alignment_best\n";
                              exit;
                           }
                        }
                     }
                  }
               }
            }
            # read length is too long: skip this
            # or N/A in the location file
            else {
               # read header and sequence lines of original reads
               $line_tmp = <$fh_org_read2>;
               $line_tmp = <$fh_org_read2>;

               $trim_length = length($line_tmp);

               if ($org_fastq_input == 1) {
                  $line_tmp = <$fh_org_read2>;
                  $line_tmp = <$fh_org_read2>;
               }

               # the number of corresponding corrected reads might be over one
               for (my $it_map = 0; $it_map < $occurrence_map; $it_map++) {
                  # read header and sequence lines of corrected reads
                  $line_tmp = <$fh_cor_read2>;
                  $line_tmp = <$fh_cor_read2>;

                  $trim_length -= length($line_tmp);

                  if ($trim_length > 0) {
                     if (!defined($in_map_file)) {
                        $num_trimmed_bases_local += $trim_length;
                     }
                  }

                  if ($cor_fastq_input == 1) {
                     $line_tmp = <$fh_cor_read2>;
                     $line_tmp = <$fh_cor_read2>;
                  }
               }
            }
         }
         #
         # end of the reverse read
         #
      }
      #
      # read for other cores
      # skip lines
      #
      else {
         # second location line
         if ($is_paired) {
            $line_location = <$fh_location>;
         }

         # original fastq files
         if ($org_fastq_input == 1) {
            $line_org_read1 = <$fh_org_read1>;
            $line_org_read1 = <$fh_org_read1>;
            $line_org_read1 = <$fh_org_read1>;
            $line_org_read1 = <$fh_org_read1>;

            if ($is_paired) {
               $line_org_read2 = <$fh_org_read2>;
               $line_org_read2 = <$fh_org_read2>;
               $line_org_read2 = <$fh_org_read2>;
               $line_org_read2 = <$fh_org_read2>;
            }
         }
         # original fasta files
         else {
            $line_org_read1 = <$fh_org_read1>;
            $line_org_read1 = <$fh_org_read1>;

            if ($is_paired) {
               $line_org_read2 = <$fh_org_read2>;
               $line_org_read2 = <$fh_org_read2>;
            }
         }

         # corrected fastq files
         for (my $it_map = 0; $it_map < $occurrence_map; $it_map++) {
            if ($cor_fastq_input == 1) {
               $line_cor_read1 = <$fh_cor_read1>;
               $line_cor_read1 = <$fh_cor_read1>;
               $line_cor_read1 = <$fh_cor_read1>;
               $line_cor_read1 = <$fh_cor_read1>;

               if ($is_paired) {
                  $line_cor_read2 = <$fh_cor_read2>;
                  $line_cor_read2 = <$fh_cor_read2>;
                  $line_cor_read2 = <$fh_cor_read2>;
                  $line_cor_read2 = <$fh_cor_read2>;
               }
            }
            # corrected fasta files
            else {
               $line_cor_read1 = <$fh_cor_read1>;
               $line_cor_read1 = <$fh_cor_read1>;

               if ($is_paired) {
                  $line_cor_read2 = <$fh_cor_read2>;
                  $line_cor_read2 = <$fh_cor_read2>;
               }
            }
         }
      }

      $num_lines++;
   }

   # check if the read files still have lines
   $line_tmp = <$fh_org_read1>;
   if (defined($line_tmp)) {
      die "\nERROR: Number of lines in the location file is not matched with that in the original read\n\n";
   }

   $line_tmp = <$fh_cor_read1>;
   if (defined($line_tmp)) {
      die "\nERROR: Number of lines in the location file is not matched with that in the corrected read\n\n";
   }

   if (defined($in_map_file)) {
      $line_tmp = <$fh_map>;
      if (defined($line_tmp)) {
         die "\nERROR: Number of lines in the location file is not matched with that in the PBcR map read\n\n";
      }
   }

   if ($is_paired) {
      $line_tmp = <$fh_org_read2>;
      if (defined($line_tmp)) {
         die "\nERROR: Number of lines in the location file is not matched with that in the original read\n\n";
      }

      $line_tmp = <$fh_cor_read2>;
      if (defined($line_tmp)) {
         die "\nERROR: Number of lines in the location file is not matched with that in the corrected read\n\n";
      }
   }

   #**********************************************************************
   # evaluate reads that are > $read_length_parallel
   #**********************************************************************
   # evaluaing long read requires large memory
   # reads that are longer than $read_length_parallel would be evaluted
   # in the core with rank 0
   if ($rank == 0) {
      # rewind file handlers

      # location file
      seek($fh_location,  0, 0);

      # map file
      if (defined($fh_map)) {
         seek($fh_map, 0, 0);
      }

      # oriiginal reads
      if ($is_paired) {
         if ($org_fastq_input == 1) {
            if ($in_org_fastq1_file =~ /\.gz$/) {
               close $fh_org_read1;
               $fh_org_read1 = IO::Uncompress::Gunzip->new($in_org_fastq1_file)
                  or die "\nERROR: Cannot open $in_org_fastq1_file\n\n"
            }
            else {
               seek($fh_org_read1, 0, 0);
            }
   
            if ($in_org_fastq2_file =~ /\.gz$/) {
               close $fh_org_read2;
               $fh_org_read2 = IO::Uncompress::Gunzip->new($in_org_fastq2_file)
                  or die "\nERROR: Cannot open $in_org_fastq2_file\n\n"
            }
            else {
               seek($fh_org_read2, 0, 0);
            }
         }
         else {
            if ($in_org_fasta1_file =~ /\.gz$/) {
               close $fh_org_read1;
               $fh_org_read1 = IO::Uncompress::Gunzip->new($in_org_fasta1_file)
                  or die "\nERROR: Cannot open $in_org_fasta1_file\n\n"
            }
            else {
               seek($fh_org_read1, 0, 0);
            }
   
            if ($in_org_fasta2_file =~ /\.gz$/) {
               close $fh_org_read2;
               $fh_org_read2 = IO::Uncompress::Gunzip->new($in_org_fasta2_file)
                  or die "\nERROR: Cannot open $in_org_fasta2_file\n\n"
            }
            else {
               seek($fh_org_read2, 0, 0);
            }
         }
      }
      else {
         if ($org_fastq_input == 1) {
            if ($in_org_fastq_file =~ /\.gz$/) {
               close $fh_org_read1;
               $fh_org_read1 = IO::Uncompress::Gunzip->new($in_org_fastq_file)
                  or die "\nERROR: Cannot open $in_org_fastq_file\n\n"
            }
            else {
               seek($fh_org_read1, 0, 0);
            }
         }
         else {
            if ($in_org_fasta_file =~ /\.gz$/) {
               close $fh_org_read1;
               $fh_org_read1 = IO::Uncompress::Gunzip->new($in_org_fasta_file)
                  or die "\nERROR: Cannot open $in_org_fasta_file\n\n"
            }
            else {
               seek($fh_org_read1, 0, 0);
            }
         }
      }

      # corrected reads
      if ($is_paired) {
         if ($cor_fastq_input == 1) {
            if ($in_cor_fastq1_file =~ /\.gz$/) {
               close $fh_cor_read1;
               $fh_cor_read1 = IO::Uncompress::Gunzip->new($in_cor_fastq1_file)
                  or die "\nERROR: Cannot open $in_cor_fastq1_file\n\n"
            }
            else {
               seek($fh_cor_read1, 0, 0);
            }
   
            if ($in_cor_fastq2_file =~ /\.gz$/) {
               close $fh_cor_read2;
               $fh_cor_read2 = IO::Uncompress::Gunzip->new($in_cor_fastq2_file)
                  or die "\nERROR: Cannot open $in_cor_fastq2_file\n\n"
            }
            else {
               seek($fh_cor_read2, 0, 0);
            }
         }
         else {
            if ($in_cor_fasta1_file =~ /\.gz$/) {
               close $fh_cor_read1;
               $fh_cor_read1 = IO::Uncompress::Gunzip->new($in_cor_fasta1_file)
                  or die "\nERROR: Cannot open $in_cor_fasta1_file\n\n"
            }
            else {
               seek($fh_cor_read1, 0, 0);
            }
   
            if ($in_cor_fasta2_file =~ /\.gz$/) {
               close $fh_cor_read2;
               $fh_cor_read2 = IO::Uncompress::Gunzip->new($in_cor_fasta2_file)
                  or die "\nERROR: Cannot open $in_cor_fasta2_file\n\n"
            }
            else {
               seek($fh_cor_read2, 0, 0);
            }
         }
      }
      else {
         if ($cor_fastq_input == 1) {
            if ($in_cor_fastq_file =~ /\.gz$/) {
               close $fh_cor_read1;
               $fh_cor_read1 = IO::Uncompress::Gunzip->new($in_cor_fastq_file)
                  or die "\nERROR: Cannot open $in_cor_fastq_file\n\n"
            }
            else {
               seek($fh_cor_read1, 0, 0);
            }
         }
         else {
            if ($in_cor_fasta_file =~ /\.gz$/) {
               close $fh_cor_read1;
               $fh_cor_read1 = IO::Uncompress::Gunzip->new($in_cor_fasta_file)
                  or die "\nERROR: Cannot open $in_cor_fasta_file\n\n"
            }
            else {
               seek($fh_cor_read1, 0, 0);
            }
         }
      }

      # process each location line
      while (my $line_location = <$fh_location>) {
         my $line_org_header1;
         my $line_org_header2;
         my $line_org_read1;
         my $line_org_read2;

         my $line_cor_header1;
         my $line_cor_header2;
         my $line_cor_read1;
         my $line_cor_read2;

         my $read_length_check;

         # read the map file
         if (defined($in_map_file)) {
            $line_map = <$fh_map>;

            if ($line_map =~ /^(\S+)\s+(\d+)/) {
               $read_name_map  = $1;
               $occurrence_map = $2;
            }
            else {
               die "\nERROR: Wrong PBcR map line $line_map\n";
            }
         }
         # if a map file is not used
         else {
            $occurrence_map = 1;
         }

         #----------------------------------------------------------------------
         # forward read
         #----------------------------------------------------------------------
         # <read name> <ref 1 or 2> <ref name> <strand> <start index> <read length> <substitutions> <insertions> <deletions>
         if ($line_location =~ /^\S+\s+[12]\s+\S+\s+[\+\-]\s+[\d\-]+\s+(\d+)\s+\S+\s+\S+\s+\S+/) {
            $read_length_check = $1;
         }
         # skip this line
         elsif ($line_location =~ /^\S+\s+N\/A\s*$/) {
            $read_length_check = $read_length_parallel - 1;
         }
         else {
            die "\nERROR: $line_location\n";
         }

         # read length is too long: process this
         if ($read_length_check > $read_length_parallel) {
            # read header and sequence lines of original reads
            $line_org_header1 = <$fh_org_read1> ;
            unless (defined($line_org_header1)) {
               die "\nERROR: Number of lines in the location file is not matched with that in the original read\n\n";
            }

            $line_org_read1 = <$fh_org_read1>;
            $line_org_read1 = uc $line_org_read1;

            # consume unnecessary lines
            if ($org_fastq_input == 1) {
               $line_tmp = <$fh_org_read1>;
               $line_tmp = <$fh_org_read1>;
            }

            chomp $line_org_header1;
            chomp $line_org_read1;

            # check original read lines
            if ($org_fastq_input == 1) {
               unless ($line_org_header1 =~ /^\@/) {
                  die "\nERROR: $line_org_header1\n";
               }
            }
            else {
               unless ($line_org_header1 =~ /^\>/) {
                  die "\nERROR: $line_org_header1\n";
               }
            }

            # there could be multiple corrected reads for one original read
            # this is because some pacbio error correction tools split reads into pieces
            for (my $it_map = 0; $it_map < $occurrence_map; $it_map++) {
               # read header and sequence lines of corrected reads
               $line_cor_header1 = <$fh_cor_read1>;
               unless (defined($line_cor_header1)) {
                  die "\nERROR: Number of lines in the location file is not matched with that in the corrected read\n\n";
               }

               $line_cor_read1 = <$fh_cor_read1>;
               $line_cor_read1 = uc $line_cor_read1;

               # consume unnecessary lines
               if ($cor_fastq_input == 1) {
                  $line_tmp = <$fh_cor_read1>;
                  $line_tmp = <$fh_cor_read1>;
               }

               chomp $line_cor_header1;
               chomp $line_cor_read1;

               # check corrected read lines
               if ($cor_fastq_input == 1) {
                  unless ($line_cor_header1 =~ /^\@/) {
                     die "\nERROR: $line_cor_header1\n";
                  }
               }
               else {
                  unless ($line_cor_header1 =~ /^\>/) {
                     die "\nERROR: $line_cor_header1\n";
                  }
               }

               # count the number of trimmed bases
               $read_length           = length($line_org_read1);
               $corrected_read_length = length($line_cor_read1);

               my $trim_length = $read_length - $corrected_read_length;
               if ($trim_length > 0) {
                  $is_trimmed = 1;
                  $num_trimmed_bases_local += $trim_length;
               }
               else {
                  $is_trimmed = 0;
               }

               # record current values
               if ($in_similarity == 0) {
                  $num_yyns_substitution_local_prev = $num_yyns_substitution_local;
                  $num_ynys_substitution_local_prev = $num_ynys_substitution_local;
                  $num_nyys_substitution_local_prev = $num_nyys_substitution_local;
                  $num_nyns_substitution_local_prev = $num_nyns_substitution_local;
                  $num_nnns_substitution_local_prev = $num_nnns_substitution_local;

                  $num_yyns_insertion_local_prev = $num_yyns_insertion_local;
                  $num_nyys_insertion_local_prev = $num_nyys_insertion_local;
                  $num_nyns_insertion_local_prev = $num_nyns_insertion_local;
                  $num_nnns_insertion_local_prev = $num_nnns_insertion_local;

                  $num_yyns_deletion_local_prev = $num_yyns_deletion_local;
                  $num_nyys_deletion_local_prev = $num_nyys_deletion_local;
                  $num_nyns_deletion_local_prev = $num_nyns_deletion_local;
                  $num_nnns_deletion_local_prev = $num_nnns_deletion_local;

                  $num_not_evaluated_substitution_local_prev = $num_not_evaluated_substitution_local;
                  $num_not_evaluated_insertion_local_prev    = $num_not_evaluated_insertion_local;
                  $num_not_evaluated_deletion_local_prev     = $num_not_evaluated_deletion_local;

                  $num_from_substitution_to_deletion_local_prev = $num_from_substitution_to_deletion_local;

                  $num_nyys_substitution_trim_local_prev = $num_nyys_substitution_trim_local;

                  $num_nyys_insertion_trim_local_prev = $num_nyys_insertion_trim_local;

                  $num_nyys_deletion_trim_local_prev = $num_nyys_deletion_trim_local;
               } 
               else {
                  $num_yyns_substitution_local_prev = $num_yyns_substitution_local;
                  $num_ynys_substitution_local_prev = $num_ynys_substitution_local;
                  $num_nyys_substitution_local_prev = $num_nyys_substitution_local;
                  $num_nyns_substitution_local_prev = $num_nyns_substitution_local;
                  $num_nnns_substitution_local_prev = $num_nnns_substitution_local;
                  
               }

               #
               # compare the first read
               #
               &compare_one_read($line_location, $line_cor_read1, $read_length, $line_org_read1);

               if ($in_similarity == 0) {
                  # check the number of processed errors
                  $total_substitutions_local += $num_substitutions;
                  $total_insertions_local    += $num_insertions;
                  $total_deletions_local     += $num_deletions;

                  # check the number of processed errors
                  # substitution
                  if ($num_substitutions > 0) {
                     if ($num_substitutions !=
                         (($num_nyys_substitution_local - $num_nyys_substitution_local_prev) +
                          ($num_nyns_substitution_local - $num_nyns_substitution_local_prev) +
                          ($num_nnns_substitution_local - $num_nnns_substitution_local_prev) +
                          ($num_from_substitution_to_deletion_local - $num_from_substitution_to_deletion_local_prev) +
                          ($num_nyys_substitution_trim_local - $num_nyys_substitution_trim_local_prev) +
                          ($num_not_evaluated_substitution_local - $num_not_evaluated_substitution_local_prev))) {
                        printf "\nERROR: $line_org_header1\nS TOTAL(%d) vs NYY /wo TRIM(%d) + NYN(%d) + NNN(%d) + NYY TRIM(%d) + NOT EVAL(%d)\n\n",
                           $num_substitutions,
                           $num_nyys_substitution_local - $num_nyys_substitution_local_prev,
                           $num_nyns_substitution_local - $num_nyns_substitution_local_prev,
                           $num_nnns_substitution_local - $num_nnns_substitution_local_prev,
                           $num_nyys_substitution_trim_local - $num_nyys_substitution_trim_local_prev,
                           $num_not_evaluated_substitution_local - $num_not_evaluated_substitution_local_prev;
                        print "$alignment_best\n";
                        exit;
                     }
                  }

                  # insertion
                  if ($num_insertions > 0) {
                     if ($num_insertions !=
                         (($num_nyys_insertion_local - $num_nyys_insertion_local_prev) +
                          ($num_nyns_insertion_local - $num_nyns_insertion_local_prev) +
                          ($num_nnns_insertion_local - $num_nnns_insertion_local_prev) +
                          ($num_nyys_insertion_trim_local - $num_nyys_insertion_trim_local_prev) +
                          ($num_not_evaluated_insertion_local - $num_not_evaluated_insertion_local_prev))) {
                        printf "\nERROR: $line_org_header1\nI TOTAL(%d) vs NYY /wo TRIM(%d) + NYN(%d) + NNN(%d) + NYY TRIM(%d) + NOT EVAL(%d)\n\n",
                           $num_insertions,
                           $num_nyys_insertion_local - $num_nyys_insertion_local_prev,
                           $num_nyns_insertion_local - $num_nyns_insertion_local_prev,
                           $num_nnns_insertion_local - $num_nnns_insertion_local_prev,
                           $num_nyys_insertion_trim_local - $num_nyys_insertion_trim_local_prev,
                           $num_not_evaluated_insertion_local - $num_not_evaluated_insertion_local_prev;
                        print "$alignment_best\n";
                        exit;
                     }
                  }

                  # deletion
                  if ($num_deletions > 0) {
                     if ($num_deletions !=
                         (($num_nyys_deletion_local - $num_nyys_deletion_local_prev) +
                          ($num_nyns_deletion_local - $num_nyns_deletion_local_prev) +
                          ($num_nnns_deletion_local - $num_nnns_deletion_local_prev) +
                          ($num_nyys_deletion_trim_local - $num_nyys_deletion_trim_local_prev) +
                          ($num_not_evaluated_deletion_local - $num_not_evaluated_deletion_local_prev))) {
                        printf "\nERROR: $line_org_header1\nD TOTAL(%d) vs NYY /wo TRIM(%d) + NYN(%d) + NNN(%d) + NYY TRIM(%d) + NOT EVAL(%d)\n\n",
                           $num_deletions,
                           $num_nyys_deletion_local - $num_nyys_deletion_local_prev,
                           $num_nyns_deletion_local - $num_nyns_deletion_local_prev,
                           $num_nnns_deletion_local - $num_nnns_deletion_local_prev,
                           $num_nyys_deletion_trim_local - $num_nyys_deletion_trim_local_prev,
                           $num_not_evaluated_deletion_local - $num_not_evaluated_deletion_local_prev;
                        print "$alignment_best\n";
                        exit;
                     }
                  }
               }
               #
               # end of forward read
               #
            }
         }
         # read length is not too long: skip this
         else {
            $line_tmp = <$fh_org_read1> ;
            $line_tmp = <$fh_org_read1>;

            if ($org_fastq_input == 1) {
               $line_tmp = <$fh_org_read1>;
               $line_tmp = <$fh_org_read1>;
            }

            # the number of corresponding corrected reads might be over one
            for (my $it_map = 0; $it_map < $occurrence_map; $it_map++) {
               $line_tmp = <$fh_cor_read1>;
               $line_tmp = <$fh_cor_read1>;

               if ($cor_fastq_input == 1) {
                  $line_tmp = <$fh_cor_read1>;
                  $line_tmp = <$fh_cor_read1>;
               }
            }
         }
         #
         # end of forward read
         #

         #----------------------------------------------------------------------
         # reverse read
         #----------------------------------------------------------------------
         if ($is_paired) {
            # take a new location line
            $line_location = <$fh_location>;

            # <read name> <ref 1 or 2> <ref name> <strand> <start index> <read length> <substitutions> <insertions> <deletions>
            if ($line_location =~ /^\S+\s+[12]\s+\S+\s+[\+\-]\s+[\d\-]+\s+(\d+)\s+\S+\s+\S+\s+\S+/) {
               $read_length_check = $1;
            }
            # skip this line
            elsif ($line_location =~ /^\S+\s+N\/A\s*$/) {
               $read_length_check = $read_length_parallel - 1;
            }
            else {
               die "\nERROR: $line_location\n";
            }

            # read length is too long: process this
            if ($read_length_check > $read_length_parallel) {
               unless (defined($line_location)) {
                  die "\nERROR: The number of reads in $in_location_file is odd\n\n";
               }
               else {
                  # read header and sequence lines of original reads
                  $line_org_header2 = <$fh_org_read2>;
                  unless (defined($line_org_header2)) {
                     die "\nERROR: Number of lines in the location file is not matched with that in the original read\n\n";
                  }

                  $line_org_read2 = <$fh_org_read2>;
                  $line_org_read2 = uc $line_org_read2;

                  # consume unnecessary lines
                  if ($org_fastq_input == 1) {
                     $line_tmp = <$fh_org_read2>;
                     $line_tmp = <$fh_org_read2>;
                  }

                  chomp $line_org_header2;
                  chomp $line_org_read2;

                  # check original read lines
                  if ($org_fastq_input == 1) {
                     unless ($line_org_header2 =~ /^\@/) {
                        die "\nERROR: $line_org_read2\n";
                     }
                  }
                  else {
                     unless ($line_org_header2 =~ /^\>/) {
                        die "\nERROR: $line_org_read2\n";
                     }
                  }

                  # there could be multiple corrected reads for one original read
                  # this is because some pacbio error correction tools split reads into pieces
                  for (my $it_map = 0; $it_map < $occurrence_map; $it_map++) {
                     # read header and sequence lines of corrected reads
                     $line_cor_header2 = <$fh_cor_read2>;
                     unless (defined($line_cor_header2)) {
                        die "\nERROR: Number of lines in the location file is not matched with that in the corrected read\n\n";
                     }

                     $line_cor_read2 = <$fh_cor_read2>;
                     $line_cor_read2 = uc $line_cor_read2;

                     # consume unnecessary lines
                     if ($cor_fastq_input == 1) {
                        $line_tmp = <$fh_cor_read2>;
                        $line_tmp = <$fh_cor_read2>;
                     }

                     chomp $line_cor_header2;
                     chomp $line_cor_read2;

                     # check corrected read lines
                     if ($cor_fastq_input == 1) {
                        unless ($line_cor_header2 =~ /^\@/) {
                           die "\nERROR: $line_cor_read2\n";
                        }
                     }
                     else {
                        unless ($line_cor_header2 =~ /^\>/) {
                           die "\nERROR: $line_cor_read2\n";
                        }
                     }

                     # count the number of trimmed bases
                     $read_length           = length($line_org_read2);
                     $corrected_read_length = length($line_cor_read2);

                     $trim_length = $read_length - $corrected_read_length;
                     if ($trim_length > 0) {
                        $is_trimmed = 1;
                        $num_trimmed_bases_local += $trim_length;
                     }
                     else {
                        $is_trimmed = 0;
                     }

                     # record current values
                     if ($in_similarity == 0) {
                        $num_yyns_substitution_local_prev = $num_yyns_substitution_local;
                        $num_ynys_substitution_local_prev = $num_ynys_substitution_local;
                        $num_nyys_substitution_local_prev = $num_nyys_substitution_local;
                        $num_nyns_substitution_local_prev = $num_nyns_substitution_local;
                        $num_nnns_substitution_local_prev = $num_nnns_substitution_local;

                        $num_yyns_insertion_local_prev = $num_yyns_insertion_local;
                        $num_nyys_insertion_local_prev = $num_nyys_insertion_local;
                        $num_nyns_insertion_local_prev = $num_nyns_insertion_local;
                        $num_nnns_insertion_local_prev = $num_nnns_insertion_local;

                        $num_yyns_deletion_local_prev = $num_yyns_deletion_local;
                        $num_nyys_deletion_local_prev = $num_nyys_deletion_local;
                        $num_nyns_deletion_local_prev = $num_nyns_deletion_local;
                        $num_nnns_deletion_local_prev = $num_nnns_deletion_local;

                        $num_not_evaluated_substitution_local_prev = $num_not_evaluated_substitution_local;
                        $num_not_evaluated_insertion_local_prev    = $num_not_evaluated_insertion_local;
                        $num_not_evaluated_deletion_local_prev     = $num_not_evaluated_deletion_local;

                        $num_from_substitution_to_deletion_local_prev = $num_from_substitution_to_deletion_local;

                        $num_nyys_substitution_trim_local_prev = $num_nyys_substitution_trim_local;

                        $num_nyys_insertion_trim_local_prev = $num_nyys_insertion_trim_local;

                        $num_nyys_deletion_trim_local_prev = $num_nyys_deletion_trim_local;
                     }

                     #
                     # compare the second read
                     #
                     &compare_one_read($line_location, $line_cor_read2, $read_length, $line_org_read2);
                     
                     if ($in_similarity == 0) {
                        # check the number of processed errors
                        $total_substitutions_local += $num_substitutions;
                        $total_insertions_local    += $num_insertions;
                        $total_deletions_local     += $num_deletions;

                        # check the number of processed errors
                        # substitution
                        if ($num_substitutions > 0) {
                           if ($num_substitutions !=
                               (($num_nyys_substitution_local - $num_nyys_substitution_local_prev) +
                                ($num_nyns_substitution_local - $num_nyns_substitution_local_prev) +
                                ($num_nnns_substitution_local - $num_nnns_substitution_local_prev) +
                                ($num_from_substitution_to_deletion_local - $num_from_substitution_to_deletion_local_prev) +
                                ($num_nyys_substitution_trim_local - $num_nyys_substitution_trim_local_prev) +
                                ($num_not_evaluated_substitution_local - $num_not_evaluated_substitution_local_prev))) {
                              printf "\nERROR: $line_org_header2\nS TOTAL(%d) vs NYY /wo TRIM(%d) + NYN(%d) + NNN(%d) + NYY TRIM(%d) + NOT EVAL(%d)\n\n",
                                 $num_substitutions,
                                 $num_nyys_substitution_local - $num_nyys_substitution_local_prev,
                                 $num_nyns_substitution_local - $num_nyns_substitution_local_prev,
                                 $num_nnns_substitution_local - $num_nnns_substitution_local_prev,
                                 $num_nyys_substitution_trim_local - $num_nyys_substitution_trim_local_prev,
                                 $num_not_evaluated_substitution_local - $num_not_evaluated_substitution_local_prev;
                              print "$alignment_best\n";
                              exit;
                           }
                        }

                        # insertion
                        if ($num_insertions > 0) {
                           if ($num_insertions !=
                               (($num_nyys_insertion_local - $num_nyys_insertion_local_prev) +
                                ($num_nyns_insertion_local - $num_nyns_insertion_local_prev) +
                                ($num_nnns_insertion_local - $num_nnns_insertion_local_prev) +
                                ($num_nyys_insertion_trim_local - $num_nyys_insertion_trim_local_prev) + 
                                ($num_not_evaluated_insertion_local - $num_not_evaluated_insertion_local_prev))) {
                              printf "\nERROR: $line_org_header2\nI TOTAL(%d) vs NYY /wo TRIM(%d) + NYN(%d) + NNN(%d) + NYY TRIM(%d) + NOT EVAL(%d)\n\n",
                                 $num_insertions,
                                 $num_nyys_insertion_local - $num_nyys_insertion_local_prev,
                                 $num_nyns_insertion_local - $num_nyns_insertion_local_prev,
                                 $num_nnns_insertion_local - $num_nnns_insertion_local_prev,
                                 $num_nyys_insertion_trim_local - $num_nyys_insertion_trim_local_prev,
                                 $num_not_evaluated_insertion_local - $num_not_evaluated_insertion_local_prev;
                              print "$alignment_best\n";
                              exit;
                           }
                        }

                        # deletion
                        if ($num_deletions > 0) {
                           if ($num_deletions !=
                               (($num_nyys_deletion_local - $num_nyys_deletion_local_prev) +
                                ($num_nyns_deletion_local - $num_nyns_deletion_local_prev) +
                                ($num_nnns_deletion_local - $num_nnns_deletion_local_prev) +
                                ($num_nyys_deletion_trim_local - $num_nyys_deletion_trim_local_prev) +
                                ($num_not_evaluated_deletion_local - $num_not_evaluated_deletion_local_prev))) {
                              printf "\nERROR: $line_org_header2\nD TOTAL(%d) vs NYY /wo TRIM(%d) + NYN(%d) + NNN(%d) + NYY TRIM(%d) + NOT EVAL(%d)\n\n",
                                 $num_deletions,
                                 $num_nyys_deletion_local - $num_nyys_deletion_local_prev,
                                 $num_nyns_deletion_local - $num_nyns_deletion_local_prev,
                                 $num_nnns_deletion_local - $num_nnns_deletion_local_prev,
                                 $num_nyys_deletion_trim_local - $num_nyys_deletion_trim_local_prev,
                                 $num_not_evaluated_deletion_local - $num_not_evaluated_deletion_local_prev;
                              print "$alignment_best\n";
                              exit;
                           }
                        }
                     }
                  }
               }
            }
            # read length is not too long: skip this
            else {
               $line_tmp = <$fh_org_read2>;
               $line_tmp = <$fh_org_read2>;

               if ($org_fastq_input == 1) {
                  $line_tmp = <$fh_org_read2>;
                  $line_tmp = <$fh_org_read2>;
               }

               # the number of corresponding corrected reads might be over one
               $line_tmp = <$fh_cor_read2>;
               $line_tmp = <$fh_cor_read2>;

               if ($cor_fastq_input == 1) {
                  $line_tmp = <$fh_cor_read2>;
                  $line_tmp = <$fh_cor_read2>;
               }
            }
         }
         #
         # end of the reverse read
         #
      }

      # check if the read files still have lines
      my $line_tmp;

      $line_tmp = <$fh_org_read1>;
      if (defined($line_tmp)) {
         die "\nERROR: Number of lines in the location file is not matched with that in the original read\n\n";
      }

      $line_tmp = <$fh_cor_read1>;
      if (defined($line_tmp)) {
         die "\nERROR: Number of lines in the location file is not matched with that in the corrected read\n\n";
      }

      if ($is_paired) {
         $line_tmp = <$fh_org_read2>;
         if (defined($line_tmp)) {
            die "\nERROR: Number of lines in the location file is not matched with that in the original read\n\n";
         }

         $line_tmp = <$fh_cor_read2>;
         if (defined($line_tmp)) {
            die "\nERROR: Number of lines in the location file is not matched with that in the corrected read\n\n";
         }
      }
   }

   # close files
   close $fh_location;
   close $fh_org_read1;
   close $fh_cor_read1;

   if (defined($fh_map)) {
      close $fh_map;
   }

   if ($is_paired) {
      close $fh_org_read2;
      close $fh_cor_read2;
   }

   if (defined($in_debug_prefix)) {
      if ($in_similarity == 1) {
         close $fh_debug_similarity;
      }
      else {
         close $fh_debug_substitution_yyn;
         #close $fh_debug_substitution_yny;
         #close $fh_debug_substitution_nyy;
         close $fh_debug_substitution_nyn;
         close $fh_debug_substitution_nnn;

         close $fh_debug_insertion_yyn;
         close $fh_debug_insertion_nyy;
         close $fh_debug_insertion_nyn;
         close $fh_debug_insertion_nnn;

         close $fh_debug_deletion_yyn;
         close $fh_debug_deletion_nyy;
         close $fh_debug_deletion_nyn;
         close $fh_debug_deletion_nnn;
      }
   }

   if (defined($in_detail_prefix)) {
      close $fh_error_index1;
      close $fh_error_index2;
   }

   if ($in_similarity == 1) {
      # wait until all the processors finish calculating local sums
      MPI_Barrier(MPI_COMM_WORLD);

      $org_num_total_bases_percent_similarity   = MPI_Reduce($org_num_total_bases_percent_similarity_local,   sub {$_[0] + $_[1]}, MPI_COMM_WORLD);
      $org_num_matched_bases_percent_similarity = MPI_Reduce($org_num_matched_bases_percent_similarity_local, sub {$_[0] + $_[1]}, MPI_COMM_WORLD);

      $cor_num_total_bases_percent_similarity   = MPI_Reduce($cor_num_total_bases_percent_similarity_local,   sub {$_[0] + $_[1]}, MPI_COMM_WORLD);
      $cor_num_matched_bases_percent_similarity = MPI_Reduce($cor_num_matched_bases_percent_similarity_local, sub {$_[0] + $_[1]}, MPI_COMM_WORLD);
      $num_yyns_substitution = MPI_Reduce($num_yyns_substitution_local, sub {$_[0] + $_[1]}, MPI_COMM_WORLD);
      $num_ynys_substitution = MPI_Reduce($num_ynys_substitution_local, sub {$_[0] + $_[1]}, MPI_COMM_WORLD);
      $num_nyys_substitution = MPI_Reduce($num_nyys_substitution_local, sub {$_[0] + $_[1]}, MPI_COMM_WORLD);
      $num_nyns_substitution = MPI_Reduce($num_nyns_substitution_local, sub {$_[0] + $_[1]}, MPI_COMM_WORLD);
      $num_nnns_substitution = MPI_Reduce($num_nnns_substitution_local, sub {$_[0] + $_[1]}, MPI_COMM_WORLD);
   }
   else {
      # copy $position_vector_local to @position_array_local
      # copy $corrected_position_vector_local to @corrected_position_array_local
      for (my $i = 0; $i <= $max_read_length; $i++) {
         $position_array_local[$i]           = evaluate::intp_getitem($position_vector_local, $i);
         $corrected_position_array_local[$i] = evaluate::intp_getitem($corrected_position_vector_local, $i);
      }

      # wait until all the processors finish calculating local sums
      MPI_Barrier(MPI_COMM_WORLD);

      # calculate total sums
      $num_yyns_substitution = MPI_Reduce($num_yyns_substitution_local, sub {$_[0] + $_[1]}, MPI_COMM_WORLD);
      $num_ynys_substitution = MPI_Reduce($num_ynys_substitution_local, sub {$_[0] + $_[1]}, MPI_COMM_WORLD);
      $num_nyys_substitution = MPI_Reduce($num_nyys_substitution_local, sub {$_[0] + $_[1]}, MPI_COMM_WORLD);
      $num_nyns_substitution = MPI_Reduce($num_nyns_substitution_local, sub {$_[0] + $_[1]}, MPI_COMM_WORLD);
      $num_nnns_substitution = MPI_Reduce($num_nnns_substitution_local, sub {$_[0] + $_[1]}, MPI_COMM_WORLD);

      $num_yyns_insertion = MPI_Reduce($num_yyns_insertion_local, sub {$_[0] + $_[1]}, MPI_COMM_WORLD);
      $num_nyys_insertion = MPI_Reduce($num_nyys_insertion_local, sub {$_[0] + $_[1]}, MPI_COMM_WORLD);
      $num_nyns_insertion = MPI_Reduce($num_nyns_insertion_local, sub {$_[0] + $_[1]}, MPI_COMM_WORLD);
      $num_nnns_insertion = MPI_Reduce($num_nnns_insertion_local, sub {$_[0] + $_[1]}, MPI_COMM_WORLD);

      $num_yyns_deletion = MPI_Reduce($num_yyns_deletion_local, sub {$_[0] + $_[1]}, MPI_COMM_WORLD);
      $num_nyys_deletion = MPI_Reduce($num_nyys_deletion_local, sub {$_[0] + $_[1]}, MPI_COMM_WORLD);
      $num_nyns_deletion = MPI_Reduce($num_nyns_deletion_local, sub {$_[0] + $_[1]}, MPI_COMM_WORLD);
      $num_nnns_deletion = MPI_Reduce($num_nnns_deletion_local, sub {$_[0] + $_[1]}, MPI_COMM_WORLD);

      $num_not_evaluated_substitution = MPI_Reduce($num_not_evaluated_substitution_local, sub {$_[0] + $_[1]}, MPI_COMM_WORLD);
      $num_not_evaluated_insertion    = MPI_Reduce($num_not_evaluated_insertion_local, sub {$_[0] + $_[1]}, MPI_COMM_WORLD);
      $num_not_evaluated_deletion     = MPI_Reduce($num_not_evaluated_deletion_local, sub {$_[0] + $_[1]}, MPI_COMM_WORLD);

      $num_from_substitution_to_deletion = MPI_Reduce($num_from_substitution_to_deletion_local, sub {$_[0] + $_[1]}, MPI_COMM_WORLD);

      $num_nyys_substitution_trim = MPI_Reduce($num_nyys_substitution_trim_local, sub {$_[0] + $_[1]}, MPI_COMM_WORLD);

      $num_nyys_insertion_trim = MPI_Reduce($num_nyys_insertion_trim_local, sub {$_[0] + $_[1]}, MPI_COMM_WORLD);

      $num_nyys_deletion_trim = MPI_Reduce($num_nyys_deletion_trim_local, sub {$_[0] + $_[1]}, MPI_COMM_WORLD);

      $total_substitutions = MPI_Reduce($total_substitutions_local, sub {$_[0] + $_[1]}, MPI_COMM_WORLD);
      $total_insertions    = MPI_Reduce($total_insertions_local, sub {$_[0] + $_[1]}, MPI_COMM_WORLD);
      $total_deletions     = MPI_Reduce($total_deletions_local, sub {$_[0] + $_[1]}, MPI_COMM_WORLD);

      $num_trimmed_bases = MPI_Reduce($num_trimmed_bases_local, sub {$_[0] + $_[1]}, MPI_COMM_WORLD);

      for (my $i = 0; $i <= $max_read_length; $i++) {
         $position_array[$i]           = MPI_Reduce($position_array_local[$i],           sub {$_[0] + $_[1]}, MPI_COMM_WORLD);
         $position_array_corrected[$i] = MPI_Reduce($corrected_position_array_local[$i], sub {$_[0] + $_[1]}, MPI_COMM_WORLD);
      }

      # find the maximum index of @position_array
      $max_read_length_real = $max_read_length;

      for (my $i = $max_read_length; $i >= 1; $i--) {
         if ($position_array[$i] > 0) {
            $max_read_length_real = $i;
            last;
         }
      }

      # every entry has 0
      if ($max_read_length_real == $max_read_length) {
         if ($position_array[$max_read_length_real] == 0) {
            $max_read_length_real = 0;
         }
      }
   }

   # calculate read length statistics
   if ($in_similarity == 1) {
      &calculate_average_read_length;
   }

   # all the collective communication calls are blocking so no MPI_Barrier is needed
   # merge and sort all the depth files
   if (defined($in_detail_prefix)) {
      if ($rank == 0) {
         # check whether sort support multithreads
         my $check_log;
         my $support_parallel;

         $check_log        = `sort --parallel 2>&1`;
         $support_parallel = 0;

         if ($check_log =~ /requires an argument/) {
            $support_parallel = 1;
         }

         # merge and sort the depth files
         my $cmd;
         $ENV{evaluate_dna_depth_prefix} = $in_detail_prefix;
         $ENV{bam2location_core}         = $in_num_threads;

         if ($support_parallel == 1) {
            $cmd = q{cat ${evaluate_dna_depth_prefix}.ref-1.rank-* | sort --parallel=$bam2location_core -k1,1n -k2,2n - > ${evaluate_dna_depth_prefix}.ref-1.merged.sorted};
         }
         else {
            $cmd = q{cat ${evaluate_dna_depth_prefix}.ref-1.rank-* | sort -k1,1n -k2,2n - > ${evaluate_dna_depth_prefix}.ref-1.merged.sorted};
         }
         system($cmd);

         if ($support_parallel == 1) {
            $cmd = q{cat ${evaluate_dna_depth_prefix}.ref-2.rank-* | sort --parallel=$bam2location_core -k1,1n -k2,2n - > ${evaluate_dna_depth_prefix}.ref-2.merged.sorted};
         }
         else {
            $cmd = q{cat ${evaluate_dna_depth_prefix}.ref-2.rank-* | sort -k1,1n -k2,2n - > ${evaluate_dna_depth_prefix}.ref-2.merged.sorted};
         }
         system($cmd);

         # initialize the histograms
         for (my $i = 0; $i <= $in_max_depth; $i++) {
            $array_num_diff_err_cor[$i] = 0;
            $array_num_diff_err_cor_corrected[$i] = 0;

            $array_num_diff_err_cor_neg[$i] = 0;
            $array_num_diff_err_cor_corrected_neg[$i] = 0;

            $array_coverage[$i] = 0;
            $array_coverage_corrected[$i] = 0;
         }

         my $prev_chr_index;
         my $new_chr_length;
         my $end_index_local;;

         my %hash_mpileup;

         #--------------------------------------------------
         # 1st reference
         #--------------------------------------------------

         # open the merged file
         # the order of chromosomes in the file follows $hash_ref_index
         open $fh_error_index_merged_sorted1, "${in_detail_prefix}.ref-1.merged.sorted"
            or die "\nERROR: Cannot open ${in_detail_prefix}.ref-1.merged.sorted\n\n";

         $prev_chr_index  = 0;
         $new_chr_length  = 0;
         $end_index_local = 0;;

         # iterate $fh_error_index_merged_sorted
         while (my $line_merged_sorted = <$fh_error_index_merged_sorted1>) {
            if ($line_merged_sorted =~ /^(\d+)\s+(\d+)\s+([ACGT])\s+([ACGT])\s+([YN])/) {
               my $chr_index = $1;
               my $err_index = $2;
               my $org_base  = $3;
               my $err_base  = $4;
               my $corrected = $5;

               # new chromosome
               if ($chr_index != $prev_chr_index) {
                  $new_chr_length = length($hash_ref_1{$hash_ref_index_to_name_1{$chr_index}});

                  # at least $max_mpileup_lines lines available
                  if ($max_mpileup_lines <= ($new_chr_length - $err_index + 1)) {
                     $end_index_local = $err_index + $max_mpileup_lines - 1;
                  }
                  # $max_mpileup_lines lines are not available
                  else {
                     $end_index_local = $new_chr_length;
                  }

                  # run mpileup
                  &run_mpileup(1, $hash_ref_index_to_name_1{$chr_index}, $err_index, $end_index_local);

                  # initialize the hash
                  %hash_mpileup = ();

                  # read the mpileup output
                  open FH_MPILEUP, "$mpileup_file"
                     or die "\nERROR: Cannot open $mpileup_file\n\n";

                  while (my $line_mpileup = <FH_MPILEUP>) {
                     if ($line_mpileup =~ /\S+\s+(\d+)\s+([ACGT])\s+\d+\s+(\S+)/) {
                        $hash_mpileup{$1} = "${2}:${3}";
                     }
                     else {
                        die "\nERROR: $line_mpileup\n\n";
                     }
                  }

                  close FH_MPILEUP;

                  # process the current line
                  # the current error index is defined in %hash_mpileup
                  if (defined($hash_mpileup{$err_index})) {
                     if ($hash_mpileup{$err_index} =~ /([ACGT]):(\S+)/) {
                        my $ref_base       = $1;
                        my $mpileup_string = $2;

                        # update histograms
                        &update_histograms(1, $chr_index, $err_base, $mpileup_string, $corrected, $err_index);
                     }
                  }
                  # the current error index is not defined in %hash_mpileup
                  else {
                     die "\nERROR: $hash_ref_index_to_name_1{$chr_index} $err_index th base is not defined in the mpileup hash (1)\n\n";
                  }

                  $prev_chr_index = $chr_index;
               }
               # same chromosome
               else {
                  # %hash_mpileup does not contain $err_index
                  if ($err_index > $end_index_local) {
                     # at least $max_mpileup_lines lines available
                     if ($max_mpileup_lines <= ($new_chr_length - $err_index + 1)) {
                        $end_index_local = $err_index + $max_mpileup_lines - 1;
                     }
                     # $max_mpileup_lines lines are not available
                     else {
                        $end_index_local = $new_chr_length;
                     }

                     # run mpileup
                     &run_mpileup(1, $hash_ref_index_to_name_1{$chr_index}, $err_index, $end_index_local);

                     # initialize the hash
                     %hash_mpileup = ();

                     # read the mpileup output
                     open FH_MPILEUP, "$mpileup_file"
                        or die "\nERROR: Cannot open $mpileup_file\n\n";

                     while (my $line_mpileup = <FH_MPILEUP>) {
                        if ($line_mpileup =~ /\S+\s+(\d+)\s+([ACGT])\s+\d+\s+(\S+)/) {
                           $hash_mpileup{$1} = "${2}:${3}";
                        }
                        else {
                           die "\nERROR: $line_mpileup\n\n";
                        }
                     }

                     close FH_MPILEUP;

                     # process the current line
                     # the current error index is defined in %hash_mpileup
                     if (defined($hash_mpileup{$err_index})) {
                        if ($hash_mpileup{$err_index} =~ /([ACGT]):(\S+)/) {
                           my $ref_base       = $1;
                           my $mpileup_string = $2;

                           # update histograms
                           &update_histograms(1, $chr_index, $err_base, $mpileup_string, $corrected, $err_index);
                        }
                     }
                     # the current error index is not defined in %hash_mpileup
                     else {
                        die "\nERROR: $hash_ref_index_to_name_1{$chr_index} $err_index th base is not defined in the mpileup hash (2)\n\n";
                     }
                  }
                  # %hash_mpileup contains $err_index
                  else {
                     # the current error index is defined in %hash_mpileup
                     if (defined($hash_mpileup{$err_index})) {
                        if ($hash_mpileup{$err_index} =~ /([ACGT]):(\S+)/) {
                           my $ref_base       = $1;
                           my $mpileup_string = $2;

                           # update histograms
                           &update_histograms(1, $chr_index, $err_base, $mpileup_string, $corrected, $err_index);
                        }
                     }
                     # the current error index is not defined in %hash_mpileup
                     else {
                        die "\nERROR: $hash_ref_index_to_name_1{$chr_index} $err_index th base is not defined in the mpileup hash (3)\n\n";
                     }
                  }
               }
            }
            else {
               die "\nERROR: $line_merged_sorted\n\n";
            }
         }

         close $fh_error_index_merged_sorted1;

         # delete temporary files
         for (my $i = 0; $i < $num_procs; $i++) {
            my $i_text = sprintf "%0*d", 3, $i;

            unlink "${in_detail_prefix}.ref-1.rank-${i_text}";
         }

         unlink "${in_detail_prefix}.ref-1.merged.sorted";

         #--------------------------------------------------
         # 2nd reference
         #--------------------------------------------------
         # open the merged file
         # the order of chromosomes in the file follows $hash_ref_index
         open $fh_error_index_merged_sorted2, "${in_detail_prefix}.ref-2.merged.sorted"
            or die "\nERROR: Cannot open ${in_detail_prefix}.ref-2.merged.sorted\n\n";

         $prev_chr_index  = 0;
         $new_chr_length  = 0;
         $end_index_local = 0;;

         # iterate $fh_error_index_merged_sorted
         while (my $line_merged_sorted = <$fh_error_index_merged_sorted2>) {
            if ($line_merged_sorted =~ /^(\d+)\s+(\d+)\s+([ACGT])\s+([ACGT])\s+([YN])/) {
               my $chr_index = $1;
               my $err_index = $2;
               my $org_base  = $3;
               my $err_base  = $4;
               my $corrected = $5;

               # new chromosome
               if ($chr_index != $prev_chr_index) {
                  $new_chr_length = length($hash_ref_2{$hash_ref_index_to_name_2{$chr_index}});

                  # at least $max_mpileup_lines lines available
                  if ($max_mpileup_lines <= ($new_chr_length - $err_index + 1)) {
                     $end_index_local = $err_index + $max_mpileup_lines - 1;
                  }
                  # $max_mpileup_lines lines are not available
                  else {
                     $end_index_local = $new_chr_length;
                  }

                  # run mpileup
                  &run_mpileup(2, $hash_ref_index_to_name_2{$chr_index}, $err_index, $end_index_local);

                  # initialize the hash
                  %hash_mpileup = ();

                  # read the mpileup output
                  open FH_MPILEUP, "$mpileup_file"
                     or die "\nERROR: Cannot open $mpileup_file\n\n";

                  while (my $line_mpileup = <FH_MPILEUP>) {
                     if ($line_mpileup =~ /\S+\s+(\d+)\s+([ACGT])\s+\d+\s+(\S+)/) {
                        $hash_mpileup{$1} = "${2}:${3}";
                     }
                     else {
                        die "\nERROR: $line_mpileup\n\n";
                     }
                  }

                  close FH_MPILEUP;

                  # process the current line
                  # the current error index is defined in %hash_mpileup
                  if (defined($hash_mpileup{$err_index})) {
                     if ($hash_mpileup{$err_index} =~ /([ACGT]):(\S+)/) {
                        my $ref_base       = $1;
                        my $mpileup_string = $2;

                        # update histograms
                        &update_histograms(2, $chr_index, $err_base, $mpileup_string, $corrected, $err_index);
                     }
                  }
                  # the current error index is not defined in %hash_mpileup
                  else {
                     die "\nERROR: $hash_ref_index_to_name_2{$chr_index} $err_index th base is not defined in the mpileup hash (4)\n\n";
                  }

                  $prev_chr_index = $chr_index;
               }
               # same chromosome
               else {
                  # %hash_mpileup does not contain $err_index
                  if ($err_index > $end_index_local) {
                     # at least $max_mpileup_lines lines available
                     if ($max_mpileup_lines <= ($new_chr_length - $err_index + 1)) {
                        $end_index_local = $err_index + $max_mpileup_lines - 1;
                     }
                     # $max_mpileup_lines lines are not available
                     else {
                        $end_index_local = $new_chr_length;
                     }

                     # run mpileup
                     &run_mpileup(2, $hash_ref_index_to_name_2{$chr_index}, $err_index, $end_index_local);

                     # initialize the hash
                     %hash_mpileup = ();

                     # read the mpileup output
                     open FH_MPILEUP, "$mpileup_file"
                        or die "\nERROR: Cannot open $mpileup_file\n\n";

                     while (my $line_mpileup = <FH_MPILEUP>) {
                        if ($line_mpileup =~ /\S+\s+(\d+)\s+([ACGT])\s+\d+\s+(\S+)/) {
                           $hash_mpileup{$1} = "${2}:${3}";
                        }
                        else {
                           die "\nERROR: $line_mpileup\n\n";
                        }
                     }

                     close FH_MPILEUP;

                     # process the current line
                     # the current error index is defined in %hash_mpileup
                     if (defined($hash_mpileup{$err_index})) {
                        if ($hash_mpileup{$err_index} =~ /([ACGT]):(\S+)/) {
                           my $ref_base       = $1;
                           my $mpileup_string = $2;

                           # update histograms
                           &update_histograms(2, $chr_index, $err_base, $mpileup_string, $corrected, $err_index);
                        }
                     }
                     # the current error index is not defined in %hash_mpileup
                     else {
                        die "\nERROR: $hash_ref_index_to_name_2{$chr_index} $err_index th base is not defined in the mpileup hash (5)\n\n";
                     }
                  }
                  # %hash_mpileup contains $err_index
                  else {
                     # the current error index is defined in %hash_mpileup
                     if (defined($hash_mpileup{$err_index})) {
                        if ($hash_mpileup{$err_index} =~ /([ACGT]):(\S+)/) {
                           my $ref_base       = $1;
                           my $mpileup_string = $2;

                           # update histograms
                           &update_histograms(2, $chr_index, $err_base, $mpileup_string, $corrected, $err_index);
                        }
                     }
                     # the current error index is not defined in %hash_mpileup
                     else {
                        die "\nERROR: $hash_ref_index_to_name_2{$chr_index} $err_index th base is not defined in the mpileup hash (6)\n\n";
                     }
                  }
               }
            }
            else {
               die "\nERROR: $line_merged_sorted\n\n";
            }
         }

         close $fh_error_index_merged_sorted2;

         # delete temporary files
         for (my $i = 0; $i < $num_procs; $i++) {
            my $i_text = sprintf "%0*d", 3, $i;

            unlink "${in_detail_prefix}.ref-2.rank-${i_text}";
         }

         unlink "${in_detail_prefix}.ref-2.merged.sorted";

         unlink $mpileup_file;
      }
   }

   #--------------------------------------------------
   # print final statistics
   #--------------------------------------------------
   #
   # accuracy
   #
   if ($rank == 0) {
      if ($in_similarity == 1) {
         my $sum;
         my $largest_nonzero_index;

         print  "     -------------------------------------------------------\n";
         print  "     1. Read Statistics\n";
         print  "     -------------------------------------------------------\n";
         print  "     Original reads\n";
         printf "          Number of reads             : %12d\n", $org_num_reads;
         printf "          Total read length           : %12d\n", $org_total_read_length;
         printf "          Coverage (for 1st reference): %12.1f\n", $org_total_read_length / $total_ref_length1;
         if ($two_references == 1) {
            printf "          Coverage (for 2nd reference): %12.1f\n", $org_total_read_length / $total_ref_length2;
         }

         print  "          NGX0 (for 1st reference)\n";
         printf "               NG10                   : %12d\n", $org_ng10_ref1;
         printf "               NG30                   : %12d\n", $org_ng30_ref1;
         printf "               NG50                   : %12d\n", $org_ng50_ref1;
         printf "               NG70                   : %12d\n", $org_ng70_ref1;
         printf "               NG90                   : %12d\n", $org_ng90_ref1;
         if ($two_references == 1) {
            print  "          NGX0 (for 2nd reference)\n";
            printf "               NG10                   : %12d\n", $org_ng10_ref2;
            printf "               NG30                   : %12d\n", $org_ng30_ref2;
            printf "               NG50                   : %12d\n", $org_ng50_ref2;
            printf "               NG70                   : %12d\n", $org_ng70_ref2;
            printf "               NG90                   : %12d\n", $org_ng90_ref2;
         }

         print  "          Read length distribution\n";
         # find a non-zero item that has the largest index
         for (my $it_array = $read_length_array_size; $it_array >= 0; $it_array--) {
            if ($org_read_length_distribution_array[$it_array] > 0) {
               $largest_nonzero_index = $it_array;
               last;
            }
         }

         if ($largest_nonzero_index == $read_length_array_size) {
            $largest_nonzero_index--;
         }

         $sum = 0;
         for (my $it_array = 0; $it_array <= $largest_nonzero_index; $it_array++) {
            $sum += $org_read_length_distribution_array[$it_array];
            printf "               < %5d                : %12d (Cumulative: %12d)\n", ($it_array + 1) * 1000, $org_read_length_distribution_array[$it_array], $sum;
         }
         if ($org_read_length_distribution_array[$read_length_array_size] > 0) {
            $sum += $cor_read_length_distribution_array[$read_length_array_size];
            printf "                >= %5d                : %12d (Cumulative: %12d)\n", $read_length_array_size * 1000, $org_read_length_distribution_array[$read_length_array_size], $sum;
         }
         print  "\n";

         print  "    Corrected reads\n";
         printf "          Number of reads             : %12d\n", $cor_num_reads;
         printf "          Total read length           : %12d\n", $cor_total_read_length;
         printf "          Coverage (for 1st reference): %12.1f\n", $cor_total_read_length / $total_ref_length1;
         if ($two_references == 1) {
            printf "          Coverage (for 2nd reference): %12.1f\n", $cor_total_read_length / $total_ref_length2;
         }

         print  "          NGX0 (for 1st reference)\n";
         printf "               NG10                   : %12d\n", $cor_ng10_ref1;
         printf "               NG30                   : %12d\n", $cor_ng30_ref1;
         printf "               NG50                   : %12d\n", $cor_ng50_ref1;
         printf "               NG70                   : %12d\n", $cor_ng70_ref1;
         printf "               NG90                   : %12d\n", $cor_ng90_ref1;
         if ($two_references == 1) {
            print  "          NGX0 (for 2nd reference)\n";
            printf "               NG10                   : %12d\n", $cor_ng10_ref2;
            printf "               NG30                   : %12d\n", $cor_ng30_ref2;
            printf "               NG50                   : %12d\n", $cor_ng50_ref2;
            printf "               NG70                   : %12d\n", $cor_ng70_ref2;
            printf "               NG90                   : %12d\n", $cor_ng90_ref2;
         }

         print  "          Read length distribution\n";
         # find a non-zero item that has the largest index
         for (my $it_array = $read_length_array_size; $it_array >= 0; $it_array--) {
            if ($cor_read_length_distribution_array[$it_array] > 0) {
               $largest_nonzero_index = $it_array;
               last;
            }
         }

         if ($largest_nonzero_index == $read_length_array_size) {
            $largest_nonzero_index--;
         }

         $sum = 0;
         for (my $it_array = 0; $it_array <= $largest_nonzero_index; $it_array++) {
            $sum += $cor_read_length_distribution_array[$it_array];
            printf "               < %5d                : %12d (Cumulative: %12d)\n", ($it_array + 1) * 1000, $cor_read_length_distribution_array[$it_array], $sum;
         }
         if ($cor_read_length_distribution_array[$read_length_array_size] > 0) {
            $sum += $cor_read_length_distribution_array[$read_length_array_size];
            printf "                >= %5d                : %12d (Cumulative: %12d)\n", $read_length_array_size * 1000, $cor_read_length_distribution_array[$read_length_array_size], $sum;
         }
         print  "\n\n";

         print  "     -------------------------------------------------------\n";
         print  "     2. Accuracy\n";
         print  "     -------------------------------------------------------\n";
         print  "     Original reads\n";
         printf "          Total read length with gaps: %12d\n", $org_num_total_bases_percent_similarity;
         printf "          Number of matched bases    : %12d\n", $org_num_matched_bases_percent_similarity;
         printf "          Percent similarity         : %12.1f\n", 100.0 * $org_num_matched_bases_percent_similarity / $org_num_total_bases_percent_similarity;
         print  "\n";
         print  "     Corrected reads\n";
         printf "          Total read length with gaps: %12d\n", $cor_num_total_bases_percent_similarity;
         printf "          Number of matched bases    : %12d\n", $cor_num_matched_bases_percent_similarity;
         printf "          Percent similarity         : %12.1f\n", 100.0 * $cor_num_matched_bases_percent_similarity / $cor_num_total_bases_percent_similarity;
         print  "\n";

         #----------------------------------------------------------------------
         #                                 |               Prediction
         #                                 -------------------------------------
         #                                 | Erroneous Base    | Error-free Base
         #                                 | (Correct Base: X) |
         #----------------------------------------------------------------------
         #         | Erroneous Base        |       NYY         |      NNN
         #         | (Correct Base: X)     |                   |
         #         | -----------------------------------------------------------
         # Results | Erroneous Base        |       NYN         |      NNN
         #         | (Correct Base: not X) |                   |
         #         | -----------------------------------------------------------
         #         | Error-free Base       |       YYN         |      YNY
         #         |                       |                   |
         #----------------------------------------------------------------------


         #----------------------------------------------------------------------
         # Overall
         #----------------------------------------------------------------------
         print  "\n";
         print  "     Error Count:\n";
         printf "          YYN                 : %12d\n", $num_yyns_substitution;
         printf "          YNY                 : %12d\n", $num_ynys_substitution;
         printf "          NYY                 : %12d\n", $num_nyys_substitution;
         printf "          NYN                 : %12d\n", $num_nyns_substitution;
         printf "          NNN                 : %12d\n", $num_nnns_substitution;

         # P: erroneous bases in original reads
         # sensitivity (recall):        TP / P =        TP / (TP + FN) =               NYY / (NYY + (NYN + NNN))
         # gain                : (TP - FP) / P = (TP - FP) / (TP + FN) = (NYY - YYN - NYN) / (NYY + (NYN + NNN))
         if ((($num_nyys_substitution) + ($num_nyns_substitution + $num_nnns_substitution)) != 0) {
            printf "          Sensitivity (recall): %12.4f\n",
            ($num_nyys_substitution) /
            (($num_nyys_substitution ) + ($num_nyns_substitution + $num_nnns_substitution));
            printf "          Gain                : %12.4f\n",
            (($num_nyys_substitution ) - ($num_yyns_substitution + $num_nyns_substitution)) /
            (($num_nyys_substitution ) + ($num_nyns_substitution + $num_nnns_substitution));
         }
         else {
            printf "          Sensitivity (recall): %12s\n", "N/A";
            printf "          Gain                : %12s\n", "N/A";
         }

         # precision: TP / (TP + FP)
         if ((($num_nyys_substitution) + ($num_yyns_substitution + $num_nyns_substitution)) != 0) {
            printf "          Precision           : %12.4f\n",
            ($num_nyys_substitution ) /
            (($num_nyys_substitution) + ($num_yyns_substitution + $num_nyns_substitution));
         }
         else {
            printf "          Precision           : %12s\n", "N/A";
         }

         # N: error-free bases in original reads
         # specificity: TN / N = TN / (FP + TN)
         if (($num_yyns_substitution + $num_ynys_substitution) != 0) {
            printf "          Specificity         : %12.4f\n",
            $num_ynys_substitution /
            ($num_yyns_substitution + $num_ynys_substitution);
         }
         else {
            printf "          Specificity         : %12s\n", "N/A";
         }

         # f-score: 2TP / (2TP + FP + FN)
         if ((2 * ($num_nyys_substitution ) + ($num_yyns_substitution + $num_nyns_substitution) + ($num_nyns_substitution + $num_nnns_substitution)) != 0) {
            printf "          F-score             : %12.4f\n",
            2 * ($num_nyys_substitution + $num_nyys_substitution) /
            (2 * ($num_nyys_substitution + $num_nyys_substitution) + ($num_yyns_substitution + $num_nyns_substitution) + ($num_nyns_substitution + $num_nnns_substitution));
         }
         else {
            printf "          F-score             : %12s\n", "N/A";
         }
         print "\n\n";
      }
      else {
         print  "     -------------------------------------------------------\n";
         print  "     1. Accuracy\n";
         print  "     -------------------------------------------------------\n";

         #----------------------------------------------------------------------
         #                                 |               Prediction
         #                                 -------------------------------------
         #                                 | Erroneous Base    | Error-free Base
         #                                 | (Correct Base: X) |
         #----------------------------------------------------------------------
         #         | Erroneous Base        |       NYY         |      NNN
         #         | (Correct Base: X)     |                   |
         #         | -----------------------------------------------------------
         # Results | Erroneous Base        |       NYN         |      NNN
         #         | (Correct Base: not X) |                   |
         #         | -----------------------------------------------------------
         #         | Error-free Base       |       YYN         |      YNY
         #         |                       |                   |
         #----------------------------------------------------------------------

         # $num_not_evaluated_* are not subtracted from denominators because poor error tools would have
         # a large number of $num_not_evaluated_*
         #

         #----------------------------------------------------------------------
         # substitution
         #----------------------------------------------------------------------
         print  "\n";
         print  "     Substitutions:\n";
         printf "          YYN                 : %12d\n", $num_yyns_substitution;
         printf "          YNY                 : %12d\n", $num_ynys_substitution;
         printf "          NYY                 : %12d\n", $num_nyys_substitution + $num_nyys_substitution_trim;
         printf "               NYY TRIM       : %12d\n", $num_nyys_substitution_trim;
         printf "          NYN                 : %12d\n", $num_nyns_substitution;
         printf "          NNN                 : %12d\n", $num_nnns_substitution;
         printf "          From SUB to DEL     : %12d\n", $num_from_substitution_to_deletion;
         printf "          Not evaluated       : %12d\n", $num_not_evaluated_substitution;

         # P: erroneous bases in original reads
         # sensitivity (recall):        TP / P =        TP / (TP + FN) =               NYY / (NYY + (NYN + NNN))
         # gain                : (TP - FP) / P = (TP - FP) / (TP + FN) = (NYY - YYN - NYN) / (NYY + (NYN + NNN))
         if ((($num_nyys_substitution + $num_nyys_substitution_trim) + ($num_nyns_substitution + $num_nnns_substitution)) != 0) {
            printf "          Sensitivity (recall): %12.4f\n",
            ($num_nyys_substitution + $num_nyys_substitution_trim) /
            (($num_nyys_substitution + $num_nyys_substitution_trim) + ($num_nyns_substitution + $num_nnns_substitution));
            printf "          Gain                : %12.4f\n",
            (($num_nyys_substitution + $num_nyys_substitution_trim) - ($num_yyns_substitution + $num_nyns_substitution)) /
            (($num_nyys_substitution + $num_nyys_substitution_trim) + ($num_nyns_substitution + $num_nnns_substitution));
         }
         else {
            printf "          Sensitivity (recall): %12s\n", "N/A";
            printf "          Gain                : %12s\n", "N/A";
         }

         # precision: TP / (TP + FP)
         if ((($num_nyys_substitution + $num_nyys_substitution_trim) + ($num_yyns_substitution + $num_nyns_substitution)) != 0) {
            printf "          Precision           : %12.4f\n",
            ($num_nyys_substitution + $num_nyys_substitution_trim) /
            (($num_nyys_substitution + $num_nyys_substitution_trim) + ($num_yyns_substitution + $num_nyns_substitution));
         }
         else {
            printf "          Precision           : %12s\n", "N/A";
         }

         # N: error-free bases in original reads
         # specificity: TN / N = TN / (FP + TN)
         if (($num_yyns_substitution + $num_ynys_substitution) != 0) {
            printf "          Specificity         : %12.4f\n",
            $num_ynys_substitution /
            ($num_yyns_substitution + $num_ynys_substitution);
         }
         else {
            printf "          Specificity         : %12s\n", "N/A";
         }

         # f-score: 2TP / (2TP + FP + FN)
         if ((2 * ($num_nyys_substitution + $num_nyys_substitution_trim) + ($num_yyns_substitution + $num_nyns_substitution) + ($num_nyns_substitution + $num_nnns_substitution)) != 0) {
            printf "          F-score             : %12.4f\n",
            2 * ($num_nyys_substitution + $num_nyys_substitution_trim) /
            (2 * ($num_nyys_substitution + $num_nyys_substitution_trim) + ($num_yyns_substitution + $num_nyns_substitution) + ($num_nyns_substitution + $num_nnns_substitution));
         }
         else {
            printf "          F-score             : %12s\n", "N/A";
         }

         #----------------------------------------------------------------------
         # insertion
         #----------------------------------------------------------------------
         print  "\n";
         print  "     Insertions:\n";
         printf "          YYN                 : %12d\n", $num_yyns_insertion;
         printf "          NYY                 : %12d\n", $num_nyys_insertion + $num_nyys_insertion_trim;
         printf "               NYY TRIM       : %12d\n", $num_nyys_insertion_trim;
         printf "          NYN                 : %12d\n", $num_nyns_insertion;
         printf "          NNN                 : %12d\n", $num_nnns_insertion;
         printf "          Not evaluated       : %12d\n", $num_not_evaluated_insertion;

         # P: erroneous bases in original reads
         # sensitivity (recall):        TP / P =        TP / (TP + FN) =               NYY / (NYY + (NYN + NNN))
         # gain                : (TP - FP) / P = (TP - FP) / (TP + FN) = (NYY - YYN - NYN) / (NYY + (NYN + NNN))
         if ((($num_nyys_insertion + $num_nyys_insertion_trim) + ($num_nyns_insertion + $num_nnns_insertion)) != 0) {
            printf "          Sensitivity (recall): %12.4f\n",
            ($num_nyys_insertion + $num_nyys_insertion_trim) /
            (($num_nyys_insertion + $num_nyys_insertion_trim) + ($num_nyns_insertion + $num_nnns_insertion));
            printf "          Gain                : %12.4f\n",
            (($num_nyys_insertion + $num_nyys_insertion_trim) - ($num_yyns_insertion + $num_nyns_insertion)) /
            (($num_nyys_insertion + $num_nyys_insertion_trim) + ($num_nyns_insertion + $num_nnns_insertion));
         }
         else {
            printf "          Sensitivity (recall): %12s\n", "N/A";
            printf "          Gain                : %12s\n", "N/A";
         }

         # precision: TP / (TP + FP)
         if ((($num_nyys_insertion + $num_nyys_insertion_trim) + ($num_yyns_insertion + $num_nyns_insertion)) != 0) {
            printf "          Precision           : %12.4f\n",
            ($num_nyys_insertion + $num_nyys_insertion_trim) /
            (($num_nyys_insertion + $num_nyys_insertion_trim) + ($num_yyns_insertion + $num_nyns_insertion));
         }
         else {
            printf "          Precision           : %12s\n", "N/A";
         }

         # f-score: 2TP / (2TP + FP + FN)
         if ((2 * ($num_nyys_insertion + $num_nyys_insertion_trim) + ($num_yyns_insertion + $num_nyns_insertion) + ($num_nyns_insertion + $num_nnns_insertion)) != 0) {
            printf "          F-score             : %12.4f\n",
            2 * ($num_nyys_insertion + $num_nyys_insertion_trim) /
            (2 * ($num_nyys_insertion + $num_nyys_insertion_trim) + ($num_yyns_insertion + $num_nyns_insertion) + ($num_nyns_insertion + $num_nnns_insertion));
         }
         else {
            printf "          F-score             : %12s\n", "N/A";
         }

         #----------------------------------------------------------------------
         # deletion
         #----------------------------------------------------------------------
         print  "\n";
         print  "     Deletions:\n";
         printf "          YYN                 : %12d\n", $num_yyns_deletion;
         printf "          NYY                 : %12d\n", $num_nyys_deletion + $num_nyys_deletion_trim;
         printf "               NYY TRIM       : %12d\n", $num_nyys_deletion_trim;
         printf "          NYN                 : %12d\n", $num_nyns_deletion;
         printf "          NNN                 : %12d\n", $num_nnns_deletion;
         printf "          Not evaluated       : %12d\n", $num_not_evaluated_deletion;

         # P: erroneous bases in original reads
         # sensitivity (recall):        TP / P =        TP / (TP + FN) =               NYY / (NYY + (NYN + NNN))
         # gain                : (TP - FP) / P = (TP - FP) / (TP + FN) = (NYY - YYN - NYN) / (NYY + (NYN + NNN))
         if ((($num_nyys_deletion + $num_nyys_deletion_trim) + ($num_nyns_deletion + $num_nnns_deletion)) != 0) {
            printf "          Sensitivity (recall): %12.4f\n",
            ($num_nyys_deletion + $num_nyys_deletion_trim) /
            (($num_nyys_deletion + $num_nyys_deletion_trim) + ($num_nyns_deletion + $num_nnns_deletion));
            printf "          Gain                : %12.4f\n",
            (($num_nyys_deletion + $num_nyys_deletion_trim) - ($num_yyns_deletion + $num_nyns_deletion)) /
            (($num_nyys_deletion + $num_nyys_deletion_trim) + ($num_nyns_deletion + $num_nnns_deletion));
         }
         else {
            printf "          Sensitivity (recall): %12s\n", "N/A";
            printf "          Gain                : %12s\n", "N/A";
         }

         # precision: TP / (TP + FP)
         if ((($num_nyys_deletion + $num_nyys_deletion_trim) + ($num_yyns_deletion + $num_nyns_deletion)) != 0) {
            printf "          Precision           : %12.4f\n",
            ($num_nyys_deletion + $num_nyys_deletion_trim) /
            (($num_nyys_deletion + $num_nyys_deletion_trim) + ($num_yyns_deletion + $num_nyns_deletion));
         }
         else {
            printf "          Precision           : %12s\n", "N/A";
         }

         # f-score: 2TP / (2TP + FP + FN)
         if ((2 * ($num_nyys_deletion + $num_nyys_deletion_trim) + ($num_yyns_deletion + $num_nyns_deletion) + ($num_nyns_deletion + $num_nnns_deletion)) != 0) {
            printf "          F-score             : %12.4f\n",
            2 * ($num_nyys_deletion + $num_nyys_deletion_trim) /
            (2 * ($num_nyys_deletion + $num_nyys_deletion_trim) + ($num_yyns_deletion + $num_nyns_deletion) + ($num_nyns_deletion + $num_nnns_deletion));
         }
         else {
            printf "          F-score             : %12s\n", "N/A";
         }

         #----------------------------------------------------------------------
         # overall (substitution + insertion + deletion)
         #----------------------------------------------------------------------
         print  "\n";
         print  "     Overall (S + I + D):\n";
         printf "          YYN                 : %12d\n", $num_yyns_substitution + $num_yyns_insertion + $num_yyns_deletion;
         printf "          NYY                 : %12d\n", $num_nyys_substitution + $num_nyys_substitution_trim + $num_nyys_insertion + $num_nyys_insertion_trim + $num_nyys_deletion + $num_nyys_deletion_trim;
         printf "               NYY TRIM       : %12d\n", $num_nyys_substitution_trim + $num_nyys_insertion_trim + $num_nyys_deletion_trim;
         printf "          NYN                 : %12d\n", $num_nyns_substitution + $num_nyns_insertion + $num_nyns_deletion;
         printf "          NNN                 : %12d\n", $num_nnns_substitution + $num_nnns_insertion + $num_nnns_deletion;
         printf "          Not evaluated       : %12d\n", $num_not_evaluated_substitution + $num_not_evaluated_insertion + $num_not_evaluated_deletion;

         # P: erroneous bases in original reads
         # sensitivity (recall):        TP / P =        TP / (TP + FN) =               NYY / (NYY + (NYN + NNN))
         # gain                : (TP - FP) / P = (TP - FP) / (TP + FN) = (NYY - YYN - NYN) / (NYY + (NYN + NNN))
         if ((($num_nyys_substitution + $num_nyys_substitution_trim + $num_nyys_insertion + $num_nyys_insertion_trim + $num_nyys_deletion + $num_nyys_deletion_trim) + ($num_nyns_substitution + $num_nnns_substitution + $num_nyns_insertion + $num_nnns_insertion + $num_nyns_deletion + $num_nnns_deletion)) != 0) {
            printf "          Sensitivity (recall): %12.4f\n",
            ($num_nyys_substitution + $num_nyys_substitution_trim + $num_nyys_insertion + $num_nyys_insertion_trim + $num_nyys_deletion + $num_nyys_deletion_trim) /
            (($num_nyys_substitution + $num_nyys_substitution_trim + $num_nyys_insertion + $num_nyys_insertion_trim +$num_nyys_deletion + $num_nyys_deletion_trim) + ($num_nyns_substitution + $num_nnns_substitution + $num_nyns_insertion + $num_nnns_insertion + $num_nyns_deletion + $num_nnns_deletion));
            printf "          Gain                : %12.4f\n",
            (($num_nyys_substitution + $num_nyys_substitution_trim + $num_nyys_insertion + $num_nyys_insertion_trim + $num_nyys_deletion + $num_nyys_deletion_trim) - ($num_yyns_substitution + $num_nyns_substitution + $num_yyns_insertion + $num_nyns_insertion + $num_yyns_deletion + $num_nyns_deletion)) /
            (($num_nyys_substitution + $num_nyys_substitution_trim + $num_nyys_insertion + $num_nyys_insertion_trim + $num_nyys_deletion + $num_nyys_deletion_trim) + ($num_nyns_substitution + $num_nnns_substitution + $num_nyns_insertion + $num_nnns_insertion + $num_nyns_deletion + $num_nnns_deletion));
         }
         else {
            printf "          Sensitivity (recall): %12s\n", "N/A";
            printf "          Gain                : %12s\n", "N/A";
         }

         # precision: TP / (TP + FP)
         if ((($num_nyys_substitution + $num_nyys_substitution_trim + $num_nyys_insertion + $num_nyys_insertion_trim + $num_nyys_deletion + $num_nyys_deletion_trim) + ($num_yyns_substitution + $num_nyns_substitution + $num_yyns_insertion + $num_nyns_insertion + $num_yyns_deletion + $num_nyns_deletion)) != 0) {
            printf "          Precision           : %12.4f\n",
            ($num_nyys_substitution + $num_nyys_substitution_trim + $num_nyys_insertion + $num_nyys_insertion_trim + $num_nyys_deletion + $num_nyys_deletion_trim) /
            (($num_nyys_substitution + $num_nyys_substitution_trim + $num_nyys_insertion + $num_nyys_insertion_trim + $num_nyys_deletion + $num_nyys_deletion_trim) + ($num_yyns_substitution + $num_nyns_substitution + $num_yyns_insertion + $num_nyns_insertion + $num_yyns_deletion + $num_nyns_deletion));
         }
         else {
            printf "          Precision           : %12s\n", "N/A";
         }

         # f-score: 2TP / (2TP + FP + FN)
         if ((2 * ($num_nyys_substitution + $num_nyys_substitution_trim + $num_nyys_insertion + $num_nyys_insertion_trim + $num_nyys_deletion + $num_nyys_deletion_trim) + ($num_yyns_substitution + $num_nyns_substitution + $num_yyns_insertion + $num_nyns_insertion + $num_yyns_deletion + $num_nyns_deletion) + ($num_nyns_substitution + $num_nnns_substitution + $num_nyns_insertion + $num_nnns_insertion + $num_nyns_deletion + $num_nnns_deletion)) != 0) {
            printf "          F-score             : %12.4f\n",
            2 * ($num_nyys_substitution + $num_nyys_substitution_trim + $num_nyys_insertion + $num_nyys_insertion_trim + $num_nyys_deletion + $num_nyys_deletion_trim) /
            (2 * ($num_nyys_substitution + $num_nyys_substitution_trim + $num_nyys_insertion + $num_nyys_insertion_trim + $num_nyys_deletion + $num_nyys_deletion_trim) + ($num_yyns_substitution + $num_nyns_substitution + $num_yyns_insertion + $num_nyns_insertion + $num_yyns_deletion + $num_nyns_deletion) + ($num_nyns_substitution + $num_nnns_substitution + $num_nyns_insertion + $num_nnns_insertion + $num_nyns_deletion + $num_nnns_deletion));
         }
         else {
            printf "          F-score             : %12s\n", "N/A";
         }

         # if reads are split into multiple micro reads
         # countinig trimmed bases is meaningless
         if (!defined($in_map_file)) {
            print "\n";

            printf "     Trimmed bases            : %12d\n", $num_trimmed_bases;
         }

         #
         # consensus
         #
         if (defined($in_detail_prefix)) {
            #
            # position
            #
            print "\n\n";
            print "     ---------------------------------------------------------\n";
            print "     2. Position\n";
            print "     ---------------------------------------------------------\n";
            print "          Index        Corrected bases\n";
            print "          ----------   ---------------------------------------\n";

            for (my $i = 1; $i <= $max_read_length_real; $i++) {
               if ($position_array[$i] == 0) {
                  printf "          %5d    : %12d out of %12d (%s)\n", $i, 0, 0, "N/A";
               }
               else {
                  printf "          %5d    : %12d out of %12d (%5.1f%%)\n", $i, $position_array_corrected[$i], $position_array[$i], 100.0 * $position_array_corrected[$i] / $position_array[$i];
               }
            }

            my $diff_sum = 0;

            print "\n\n";
            print "     ---------------------------------------------------------\n";
            print "     3. Differential Supporting Read Coverage\n";
            print "     ---------------------------------------------------------\n";
            print "          Difference   Corrected bases\n";
            print "          ----------   ---------------------------------------\n";

            # diff: -$in_max_depth
            if ($array_num_diff_err_cor_neg[$in_max_depth] == 0) {
               printf "       %10d<=: %12d out of %12d (%s)\n", -$in_max_depth, 0, 0, "N/A";
            }
            else {
               printf "       %10d<=: %12d out of %12d (%5.1f%%)\n", -$in_max_depth, $array_num_diff_err_cor_corrected_neg[$in_max_depth], $array_num_diff_err_cor_neg[$in_max_depth], 100.0 * $array_num_diff_err_cor_corrected_neg[$in_max_depth] / $array_num_diff_err_cor_neg[$in_max_depth];

               $diff_sum += $array_num_diff_err_cor_neg[$in_max_depth];
            }

            # diff: from -($in_max_depth - 1) to -1
            for (my $i = ($in_max_depth - 1); $i > 0; $i--) {
               if ($array_num_diff_err_cor_neg[$i] == 0) {
                  printf "         %10d: %12d out of %12d (%s)\n", -$i, 0, 0, "N/A";
               }
               else {
                  printf "         %10d: %12d out of %12d (%5.1f%%)\n", -$i, $array_num_diff_err_cor_corrected_neg[$i], $array_num_diff_err_cor_neg[$i], 100.0 * $array_num_diff_err_cor_corrected_neg[$i] / $array_num_diff_err_cor_neg[$i];

                  $diff_sum += $array_num_diff_err_cor_neg[$i];
               }
            }

            # diff: from 0 to in_max_depth
            for (my $i = 0; $i < $in_max_depth; $i++) {
               if ($array_num_diff_err_cor[$i] == 0) {
                  printf "         %10d: %12d out of %12d (%s)\n", $i, 0, 0, "N/A";
               }
               else {
                  printf "         %10d: %12d out of %12d (%5.1f%%)\n", $i, $array_num_diff_err_cor_corrected[$i], $array_num_diff_err_cor[$i], 100.0 * $array_num_diff_err_cor_corrected[$i] / $array_num_diff_err_cor[$i];

                  $diff_sum += $array_num_diff_err_cor[$i];
               }
            }

            # diff: positive max
            if ($array_num_diff_err_cor[$in_max_depth] == 0) {
               printf "       %10d>=: %12d out of %12d (%s)\n", $in_max_depth, 0, 0, "N/A";
            }
            else {
               printf "       %10d>=: %12d out of %12d (%5.1f%%)\n", $in_max_depth, $array_num_diff_err_cor_corrected[$in_max_depth], $array_num_diff_err_cor[$in_max_depth], 100.0 * $array_num_diff_err_cor_corrected[$in_max_depth] / $array_num_diff_err_cor[$in_max_depth];

               $diff_sum += $array_num_diff_err_cor[$in_max_depth];
            }

            print "\n\n";
            print "     ---------------------------------------------------------\n";
            print "     4. Supporting Read Coverage of Correct Bases\n";
            print "     ---------------------------------------------------------\n";
            print "          Coverage     Corrected bases\n";
            print "          ----------   ---------------------------------------\n";

            # coverage: from 0 to in_max_depth
            for (my $i = 0; $i < $in_max_depth; $i++) {
               if ($array_coverage[$i] == 0) {
                  printf "         %10d: %12d out of %12d (%s)\n", $i, 0, 0, "N/A";
               }
               else {
                  printf "         %10d: %12d out of %12d (%5.1f%%)\n", $i, $array_coverage_corrected[$i], $array_coverage[$i], 100.0 * $array_coverage_corrected[$i] / $array_coverage[$i];
               }
            }

            # coverage: in_max_depth
            if ($array_coverage[$in_max_depth] == 0) {
               printf "       %10d>=: %12d out of %12d (%s)\n", $in_max_depth, 0, 0, "N/A";
            }
            else {
               printf "       %10d>=: %12d out of %12d (%5.1f%%)\n", $in_max_depth, $array_coverage_corrected[$in_max_depth], $array_coverage[$in_max_depth], 100.0 * $array_coverage_corrected[$in_max_depth] / $array_coverage[$in_max_depth];
            }
         }

         print "\n";
         print "     Comparing reads: done\n";
      }
   }

   # delete the histogram array
   evaluate::delete_intp($position_vector_local);
   evaluate::delete_intp($corrected_position_vector_local);
}

#----------------------------------------------------------------------
# compare_one_read
#----------------------------------------------------------------------
sub compare_one_read {
   # parse arguments
   my ($line_location, $corrected_read, $read_length, $original_read) = @_;

   # initialize variables
   my $ref_seq_outer_length_left  = $in_ref_seq_outer_length;
   my $ref_seq_outer_length_right = $in_ref_seq_outer_length;

   # lines that we are interested in
   # <read name> <ref 1 or 2> <ref name> <strand> <start index> <read length> <substitutions> <insertions> <deletions>
   if ($line_location =~ /^(\S+)\s+([12])\s+(\S+)\s+([\+\-])\s+([\d\-]+)\s+\d+\s+(\S+)\s+(\S+)\s+(\S+)/) {
         $read_name       = $1;

         $ref_1_or_2_prev = $ref_1_or_2;
         $ref_1_or_2      = $2;

         $seq_name_prev   = $seq_name;
         $seq_name        = $3;

         $strand          = $4;
      my $position        = $5; # start from 1
         $substitution    = $6;
         $insertion       = $7;
         $deletion        = $8;
      #print "\n";
      #print $read_name;
      #print "\n";
      if($in_similarity){
      }
   
      if ($in_one_ref) {
         # a current chromosome is not same as a previous one
         if ($seq_name ne $seq_name_prev) {
            if ($ref_1_or_2 eq "1") {
               # remove the previous chromosome
               if ($ref_1_or_2_prev eq "1") {
                  delete $hash_ref_1{$seq_name_prev};
               }
               else {
                  delete $hash_ref_2{$seq_name_prev};
               }

               # load only one chromosome
               &read_ref_chromosome($in_ref1_file, $seq_name, \%hash_ref_1);
            }
            elsif ($ref_1_or_2 eq "2") {
               # remove the previous chromosome
               if ($ref_1_or_2_prev eq "1") {
                  delete $hash_ref_1{$seq_name_prev};
               }
               else {
                  delete $hash_ref_2{$seq_name_prev};
               }

               # load only one chromosome
               &read_ref_chromosome($in_ref2_file, $seq_name, \%hash_ref_2);
            }
         }
         # samt sequence name
         # but a current reference number is not same as a previous one
         elsif ($ref_1_or_2 ne $ref_1_or_2_prev) {
            if ($ref_1_or_2 eq "1") {
               # remove the previous chromosome
               $hash_ref_2{$seq_name_prev} = "";

               # load only one chromosome
               &read_ref_chromosome($in_ref1_file, $seq_name, \%hash_ref_1);
            }
            else {
               # remove the previous chromosome
               $hash_ref_1{$seq_name_prev} = "";

               # load only one chromosome
               &read_ref_chromosome($in_ref2_file, $seq_name, \%hash_ref_2);
            }
         }
      }

      #--------------------------------------------------
      # a corrected read is same as an original read
      #--------------------------------------------------
      if ($corrected_read eq $original_read) {
         # alignment length = read_length + num_deletions
         # number of matched bases = read_length - num_substitutions - num_insertions
         # =============X====---=============X============
         if ($in_similarity == 1) {
            $cor_num_total_bases_percent_similarity_local   += ($read_length + $num_deletions);
            $cor_num_matched_bases_percent_similarity_local += ($read_length - $num_substitutions - $num_insertions);
            if (defined($in_debug_prefix)) {
               print $fh_debug_similarity "\@$read_name (NO CHANGE)\n";
            }
         
            # length of the partial reference sequence
            $ref_length_taken = $read_length - $num_insertions + $num_deletions;

            # start_index: 1-based
            $start_index = $position;

            # end_index: 1-based
            $end_index = $start_index + $ref_length_taken - 1;

            # substitutions
            if ((scalar keys %hash_substitution_org) > 0) {
               $num_nnns_substitution_local += $num_substitutions;
            } 
            $num_ynys_substitution_local += ($read_length - (scalar keys %hash_substitution_org) - $num_deletions);

            if ((scalar keys %hash_insertion) > 0) {
               $num_nnns_substitution_local += $num_insertions;

               if (defined($in_debug_prefix)) {
                  print $fh_debug_insertion_nnn "\@$read_name (NO CHANGE)\n";
               }
            }

            if ((scalar keys %hash_deletion) > 0) {
               $num_nnns_substitution_local += $num_deletions;

               if (defined($in_debug_prefix)) {
                  print $fh_debug_deletion_nnn "\@$read_name (NO CHANGE)\n";
               }
            }
         }
         else {
            # length of the partial reference sequence
            $ref_length_taken = $read_length - $num_insertions + $num_deletions;

            # start_index: 1-based
            $start_index = $position;

            # end_index: 1-based
            $end_index = $start_index + $ref_length_taken - 1;

            # substitutions
            if ((scalar keys %hash_substitution_org) > 0) {
               $num_nnns_substitution_local += $num_substitutions;

               foreach my $each_key (keys %hash_substitution_org) {
                  # update @position_array*
                  evaluate::intp_setitem($position_vector_local, $each_key, evaluate::intp_getitem($position_vector_local, $each_key) + 1);

                  if (defined($in_detail_prefix)) {
                     my $current_index;
                     my $org_base;
                     my $err_base;

                     # calculate the index of the error in the reference sequence
                     if ($strand eq "+") {
                        # both $start_index and $each_key are 1-based
                        $current_index = $start_index + $each_key - 1;

                        $org_base = $hash_substitution_org{$each_key};
                        $err_base = $hash_substitution_err{$each_key};
                     }
                     elsif ($strand eq "-") {
                        # both $end_index and $each_key are 1-based
                        $current_index = $end_index - $each_key + 1;
                        $org_base = $hash_complement{$hash_substitution_org{$each_key}};
                        $err_base = $hash_complement{$hash_substitution_err{$each_key}};
                     }
                     else {
                        die "\nERROR: Illegal strand $strand\n\n";
                     }

                     if ($ref_1_or_2 == 1) {
                        print $fh_error_index1 "$hash_ref_name_to_index_1{$seq_name} $current_index $org_base $err_base N CASE01 $read_name $start_index $end_index\n";
                     }
                     elsif ($ref_1_or_2 == 2) {
                        print $fh_error_index2 "$hash_ref_name_to_index_2{$seq_name} $current_index $org_base $err_base N CASE01 $read_name $start_index $end_index\n";
                     }
                     else {
                        die "\nERROR: Illegal reference identifier $ref_1_or_2\n\n";
                     }
                  }
               }
               if (defined($in_debug_prefix)) {
                  print $fh_debug_substitution_nnn "\@$read_name (NO CHANGE)\n";
               }
            }

            $num_ynys_substitution_local += ($read_length - (scalar keys %hash_substitution_org) - $num_deletions);

            if ((scalar keys %hash_insertion) > 0) {
               $num_nnns_insertion_local += $num_insertions;

               if (defined($in_debug_prefix)) {
                  print $fh_debug_insertion_nnn "\@$read_name (NO CHANGE)\n";
               }
            }

            if ((scalar keys %hash_deletion) > 0) {
               $num_nnns_deletion_local += $num_deletions;

               if (defined($in_debug_prefix)) {
                  print $fh_debug_deletion_nnn "\@$read_name (NO CHANGE)\n";
               }
            }
         }
      }
      # a corrected read is not same as an original read
      else {
         #--------------------------------------------------
         # restore a corrsponding reference sequence
         #--------------------------------------------------
         # adjust $ref_seq_outer_length_left
         # $positioin: 1-based
         if ($position <= $ref_seq_outer_length_left) {
            $ref_seq_outer_length_left = $position - 1;
         }

         # adjust $ref_seq_outer_length_right
         # $positioin: 1-based
         # compare the remaining length with the required length
         if ($ref_1_or_2 eq "1") {
            if ((length($hash_ref_1{$seq_name}) - $position + 1) < ($read_length - $num_insertions + $num_deletions +  $ref_seq_outer_length_right)) {
               $ref_seq_outer_length_right = (length($hash_ref_1{$seq_name}) - $position + 1) - ($read_length - $num_insertions + $num_deletions);
            }
         }
         elsif ($ref_1_or_2 eq "2") {
            if ((length($hash_ref_2{$seq_name}) - $position + 1) < ($read_length - $num_insertions + $num_deletions +  $ref_seq_outer_length_right)) {
               $ref_seq_outer_length_right = (length($hash_ref_2{$seq_name}) - $position + 1) - ($read_length - $num_insertions + $num_deletions);
            }
         }
         else {
            die "\nERROR: Illegal reference sequence $ref_1_or_2\n\n";
         }

         # start_index: 1-based
         $start_index = $position - $ref_seq_outer_length_left;

         # $start_index should be >= 1
         if ($start_index < 1) {
            die "\nERROR: Wrong \$start_index $start_index\n\n";
         }

         # length of the partial reference sequence
         $ref_length_taken = $read_length - $num_insertions + $num_deletions + $ref_seq_outer_length_left + $ref_seq_outer_length_right;

         # end_index: 1-based
         $end_index = $start_index + $ref_length_taken - 1;

         my $original_seq;
         if ($ref_1_or_2 eq "1") {
            $original_seq = substr($hash_ref_1{$seq_name}, $start_index - 1, $ref_length_taken);
            $original_seq = uc $original_seq;

            if ($strand eq "-") {
               $original_seq = reverse $original_seq;
               $original_seq =~ s/A/A_/g;
               $original_seq =~ s/C/C_/g;
               $original_seq =~ s/G/G_/g;
               $original_seq =~ s/T/T_/g;
               $original_seq =~ s/A_/T-/g;
               $original_seq =~ s/C_/G-/g;
               $original_seq =~ s/G_/C-/g;
               $original_seq =~ s/T_/A-/g;
               $original_seq =~ s/-//g;
            }
         }
         # $two_references was already checked
         elsif ($ref_1_or_2 eq "2") {
            $original_seq = substr($hash_ref_2{$seq_name}, $start_index - 1, $ref_length_taken);
            $original_seq = uc $original_seq;

            if ($strand eq "-") {
               $original_seq = reverse $original_seq;
               $original_seq =~ s/A/A_/g;
               $original_seq =~ s/C/C_/g;
               $original_seq =~ s/G/G_/g;
               $original_seq =~ s/T/T_/g;
               $original_seq =~ s/A_/T-/g;
               $original_seq =~ s/C_/G-/g;
               $original_seq =~ s/G_/C-/g;
               $original_seq =~ s/T_/A-/g;
               $original_seq =~ s/-//g;
            }
         }
         else {
            die "\nERROR: Illegal reference sequence $ref_1_or_2\n\n";
         }
         # swap $ref_seq_outer_length_left and $ref_seq_outer_length_right for - strand
         if ($strand eq "-") {
            my $outer_length_tmp = $ref_seq_outer_length_left;

            $ref_seq_outer_length_left  = $ref_seq_outer_length_right;
            $ref_seq_outer_length_right = $outer_length_tmp;
         }


         my $length_tmp = length($original_seq);

         $ref_seq_outer_5_prime = substr($original_seq, 0,                                         $ref_seq_outer_length_left);
         $ref_seq_outer_3_prime = substr($original_seq, $length_tmp - $ref_seq_outer_length_right, $ref_seq_outer_length_right);
         $original_seq          = substr($original_seq, $ref_seq_outer_length_left,                $length_tmp - $ref_seq_outer_length_left - $ref_seq_outer_length_right);

         # adjust varialbles
         $start_index      += $ref_seq_outer_length_left;
         $end_index        -= $ref_seq_outer_length_right;
         $ref_length_taken -= ($ref_seq_outer_length_left + $ref_seq_outer_length_right);

         # non-trimmed read
         my $is_extensible_longer_corrected_read = 0;
         my $is_nonextensible_longer_corrected_read = 0;
         my $difference = 0;

         if ($is_trimmed == 0) {
            # handle a corrected read that is longer than an original one
            if (length($corrected_read) > (length($original_read) + $num_deletions)) {
               $difference = length($corrected_read) - (length($original_read) + $num_deletions);

               # $original_read can be extended
               if ($difference <= $ref_seq_outer_length_right) {
                  # original_seq and original_read are updated
                  $original_seq     .= substr($ref_seq_outer_3_prime, 0, $difference);
                  $ref_length_taken += $difference;

                  $ref_seq_outer_3_prime = substr($ref_seq_outer_3_prime, $difference, $ref_seq_outer_length_right - $difference);
                  $ref_seq_outer_length_right -= $difference;

                  $is_extensible_longer_corrected_read = 1;

                  if ($strand eq "+") {
                     $end_index += $difference;
                  }
                  elsif ($strand eq "-") {
                     $start_index -= $difference;
                  }
                  else {
                     die "\nERROR: Illegal strand $strand\n\n";
                  }

                  # the original read is lengthened
                  $original_read .= substr($ref_seq_outer_3_prime, 0, $difference);
                  $read_length = length($corrected_read);
               }
               # $original_read cannot be extended
               # wrong extension
               else {
                  $corrected_read = substr($corrected_read, 0, length($original_read));

                  $is_nonextensible_longer_corrected_read = 1;
               }
            }
         }

         #--------------------------------------------------
         # generate an alignment result
         # original_seq: sequence taken from the reference sequence
         # needleman and wunsch algorithm is too expensive in terms of runtime
         # use it when it is really needed
         #--------------------------------------------------
         # no indel in the original read
         if (($num_insertions + $num_deletions) == 0) {
            # no trimmed base
            # the length of the region where the original read originates == modified read length
            if ($is_trimmed == 0) {
               if (($is_extensible_longer_corrected_read == 1) ||
                   ($is_nonextensible_longer_corrected_read == 1)) {
                  &evaluate_indel_trim($original_seq, $original_read, $corrected_read, $read_length);
               }
               else {
                  &evaluate_substitution($original_seq, $original_read, $corrected_read);
                  $alignment_best = "$original_seq\n$corrected_read\n";
               }
            }
            # trimmed bases
            # because there is no insertion and deletion, the two length should be same
            # if there is no trimmed base
            else {
               &evaluate_indel_trim($original_seq, $original_read, $corrected_read, $read_length);

            }
         }
         # indels in the original read
         else {
            &evaluate_indel_trim($original_seq, $original_read, $corrected_read, $read_length);
         }

         # a corrected read is longer than an original read
         # but the corrected read cannot be extended
         # the outer bases in the corrected read are regarded as insertions
         if ($is_nonextensible_longer_corrected_read == 1) {
            $num_yyns_insertion_local += $difference;

            # alignment score is not changed
            # because the same score is added to every alignment
         }

         if (defined($in_debug_prefix)) {
            if ($in_similarity) {
               print $fh_debug_similarity "\@$read_name\n";
               print $fh_debug_similarity $alignment_best;
            }
            else {
               # substitution
               if ($num_yyns_substitution_local_prev < $num_yyns_substitution_local) {
                  print $fh_debug_substitution_yyn "\@$read_name\n";
                  print $fh_debug_substitution_yyn $alignment_best;
               }

               if ($num_nyns_substitution_local_prev < $num_nyns_substitution_local) {
                  print $fh_debug_substitution_nyn "\@$read_name\n";
                  print $fh_debug_substitution_nyn $alignment_best;
               }

               if ($num_nnns_substitution_local_prev < $num_nnns_substitution_local) {
                  print $fh_debug_substitution_nnn "\@$read_name\n";
                  print $fh_debug_substitution_nnn $alignment_best;
               }

               # insertion
               if ($num_yyns_insertion_local_prev < $num_yyns_insertion_local) {
                  print $fh_debug_insertion_yyn "\@$read_name\n";
                  print $fh_debug_insertion_yyn $alignment_best;
                  print $fh_debug_insertion_yyn "5-end: $ref_seq_outer_5_prime\n";
                  print $fh_debug_insertion_yyn "3-end: $ref_seq_outer_3_prime\n";
               }

               if (($num_nyys_insertion_local_prev + $num_nyys_insertion_trim_local_prev) < ($num_nyys_insertion_local + $num_nyys_insertion_trim_local)) {
                  print $fh_debug_insertion_nyy "\@$read_name\n";
                  print $fh_debug_insertion_nyy $alignment_best;
               }

               if ($num_nyns_insertion_local_prev < $num_nyns_insertion_local) {
                  print $fh_debug_insertion_nyn "\@$read_name\n";
                  print $fh_debug_insertion_nyn $alignment_best;
               }

               if ($num_nnns_insertion_local_prev < $num_nnns_insertion_local) {
                  print $fh_debug_insertion_nnn "\@$read_name\n";
                  print $fh_debug_insertion_nnn $alignment_best;
               }

               # deletion
               if ($num_yyns_deletion_local_prev < $num_yyns_deletion_local) {
                  print $fh_debug_deletion_yyn "\@$read_name\n";
                  print $fh_debug_deletion_yyn $alignment_best;
               }

               if (($num_nyys_deletion_local_prev + $num_nyys_deletion_trim_local_prev) < ($num_nyys_deletion_local + $num_nyys_deletion_trim_local)) {
                  print $fh_debug_deletion_nyy "\@$read_name\n";
                  print $fh_debug_deletion_nyy $alignment_best;
               }

               if ($num_nyns_deletion_local_prev < $num_nyns_deletion_local) {
                  print $fh_debug_deletion_nyn "\@$read_name\n";
                  print $fh_debug_deletion_nyn $alignment_best;
               }

               if ($num_nnns_deletion_local_prev < $num_nnns_deletion_local) {
                  print $fh_debug_deletion_nnn "\@$read_name\n";
                  print $fh_debug_deletion_nnn $alignment_best;
               }
            }
         }
      }
   }
   # not aligned read
   elsif ($line_location =~ /^\S+\s+N\/A\s*$/) {
      # do nothing
   }
   else {
      die "\nERROR: Illegal location line $line_location\n";
   }
}



#----------------------------------------------------------------------
# evaluate_indel_trim
#----------------------------------------------------------------------
sub evaluate_indel_trim {
   if ($in_similarity) {
      # pass the variables from the perl variables to the python variables
      $evaluate::deletions             = $deletion;
      $evaluate::end_index             = $end_index;
      $evaluate::gap_extension_penalty = $in_gap_extension_penalty;
      $evaluate::gap_opening_penalty   = $in_gap_opening_penalty;
      $evaluate::insertions            = $insertion;
      $evaluate::match_gain            = $in_match_gain;
      $evaluate::max_candidates        = 1;
      $evaluate::max_read_length       = $max_read_length;
      $evaluate::mismatch_penalty      = $in_mismatch_penalty;
      $evaluate::outer_3_end           = $ref_seq_outer_3_prime;
      $evaluate::outer_5_end           = $ref_seq_outer_5_prime;
      $evaluate::read_length           = $_[3];
      $evaluate::read_name             = $read_name;
      $evaluate::start_index           = $start_index;
      $evaluate::strand                = $strand;
      $evaluate::string1               = $_[0];
      $evaluate::string2               = $_[2];

      if ($in_penalize_end_gap) {
         $evaluate::no_end_gap_penalty = 0;
      }
      else {
         $evaluate::no_end_gap_penalty = 1;
      }

      if ($ref_1_or_2 == 1) {
         $evaluate::ref_seq_index = int($hash_ref_name_to_index_1{$seq_name});
      }
      elsif ($ref_1_or_2 == 2) {
         $evaluate::ref_seq_index = int($hash_ref_name_to_index_2{$seq_name});
      }
      else {
         die "\nERROR: Illegal reference identifier $ref_1_or_2\n\n";
      }

      # initialize c variables
      evaluate::initialize_variables();

      # decode the error information
      evaluate::decode_errors();

      # fill the alignment matrixes using dynamic programming
      evaluate::fill_matrixes();

      evaluate::calculate_percent_similarity();

      # pass the variables from the c++ variables to the perl variables
      $cor_num_total_bases_percent_similarity_local   += $evaluate::num_total_bases_percent_similarity;
      $cor_num_matched_bases_percent_similarity_local += $evaluate::num_matched_bases_percent_similarity;

      # check the number of processed errors
      
         my $count_out = "count.out";
         $ENV{dp_corr_read} = $_[2];
         $ENV{dp_orig_read} = $_[1];
         $ENV{dp_ref_sequence} = $_[0];
         $ENV{dp_count_out} = $count_out;
         
       #  print "\n INDEL \n";
       #  print "\n Reference \n";
       #  print $ENV{dp_ref_sequence};
       #  print "\n Orig \n";
       #  print $ENV{dp_orig_read};
       #  print "\n Corr \n";
       #  print $ENV{dp_corr_read};
       #  print "\n";
         my $cmd1;
         $cmd1 = q{python run.py $dp_ref_sequence $dp_orig_read $dp_corr_read > $dp_count_out};
         system($cmd1);

         open FH_COUNT, "$count_out"
           or die "\nERROR: Cannot open $count_out\n\n";
         #my $cmd2 = q{cat $dp_count_out};
         #system($cmd2);   
         my @error_count = (0,0,0,0,0); 
         @error_count = <FH_COUNT>;

         close FH_COUNT;
         
         $num_yyns_substitution_local             += $error_count[0];
         $num_ynys_substitution_local             += $error_count[1];
         $num_nyys_substitution_local             += $error_count[2];
         $num_nyns_substitution_local             += $error_count[3];
         $num_nnns_substitution_local             += $error_count[4];
          
      

     # $alignment_best = $evaluate::alignment_best;
   }
   else {
      # pass the variables from the perl variables to the c++ variables
      $evaluate::deletions             = $deletion;
      $evaluate::end_index             = $end_index;
      $evaluate::gap_extension_penalty = $in_gap_extension_penalty;
      $evaluate::gap_opening_penalty   = $in_gap_opening_penalty;
      $evaluate::insertions            = $insertion;
      $evaluate::is_detail             = defined($in_detail_prefix);
      $evaluate::is_trimmed            = $is_trimmed;
      $evaluate::match_gain            = $in_match_gain;
      $evaluate::max_candidates        = $in_max_candidates;
      $evaluate::max_read_length       = $max_read_length;
      $evaluate::mismatch_penalty      = $in_mismatch_penalty;
      $evaluate::outer_3_end           = $ref_seq_outer_3_prime;
      $evaluate::outer_5_end           = $ref_seq_outer_5_prime;
      $evaluate::read_length           = $_[3];
      $evaluate::read_name             = $read_name;
      $evaluate::start_index           = $start_index;
      $evaluate::strand                = $strand;
      $evaluate::string1               = $_[0];
      $evaluate::string2               = $_[2];
      $evaluate::substitutions         = $substitution;

      if ($in_penalize_end_gap) {
         $evaluate::no_end_gap_penalty = 0;
      }
      else {
         $evaluate::no_end_gap_penalty = 1;
      }

      my $var_tmp;
      if ($ref_1_or_2 == 1) {
         $evaluate::ref_seq_index = int($hash_ref_name_to_index_1{$seq_name});
      }
      elsif ($ref_1_or_2 == 2) {
         $evaluate::ref_seq_index = int($hash_ref_name_to_index_2{$seq_name});
      }
      else {
         die "\nERROR: Illegal reference identifier $ref_1_or_2\n\n";
      }

      # initialize c variables
      evaluate::initialize_variables();

      # decode the error information
      evaluate::decode_errors();

      # fill the alignment matrixes using dynamic programming
      evaluate::fill_matrixes();

      # choose the best alignment among the candidtates
      evaluate::find_best_alignment($position_vector_local, $corrected_position_vector_local);

      # pass the variables from the c++ variables to the perl variables
      if ($evaluate::too_many_candidates == 0) {
         $num_yyns_substitution_local             += $evaluate::num_yyns_substitution_local_best;
         $num_ynys_substitution_local             += $evaluate::num_ynys_substitution_local_best;
         $num_nyys_substitution_local             += $evaluate::num_nyys_substitution_local_best;
         $num_nyns_substitution_local             += $evaluate::num_nyns_substitution_local_best;
         $num_nnns_substitution_local             += $evaluate::num_nnns_substitution_local_best;
         $num_yyns_insertion_local                += $evaluate::num_yyns_insertion_local_best;
         $num_nyys_insertion_local                += $evaluate::num_nyys_insertion_local_best;
         $num_nyns_insertion_local                += $evaluate::num_nyns_insertion_local_best;
         $num_nnns_insertion_local                += $evaluate::num_nnns_insertion_local_best;
         $num_yyns_deletion_local                 += $evaluate::num_yyns_deletion_local_best;
         $num_nyys_deletion_local                 += $evaluate::num_nyys_deletion_local_best;
         $num_nyns_deletion_local                 += $evaluate::num_nyns_deletion_local_best;
         $num_nnns_deletion_local                 += $evaluate::num_nnns_deletion_local_best;
         $num_from_substitution_to_deletion_local += $evaluate::num_from_substitution_to_deletion_local_best;
         $num_nyys_substitution_trim_local        += $evaluate::num_nyys_substitution_trim_local_best;
         $num_nyys_insertion_trim_local           += $evaluate::num_nyys_insertion_trim_local_best;
         $num_nyys_deletion_trim_local            += $evaluate::num_nyys_deletion_trim_local_best;

         $alignment_best = $evaluate::alignment_best;

         if ($in_detail_prefix) {
            if ($ref_1_or_2 == 1) {
               print $fh_error_index1 $evaluate::error_index_best;
            }
            elsif ($ref_1_or_2 == 2) {
               print $fh_error_index2 $evaluate::error_index_best;
            }
         }
      }
      else {
         $num_not_evaluated_substitution_local += $evaluate::num_not_evaluated_substitution;
         $num_not_evaluated_insertion_local    += $evaluate::num_not_evaluated_insertion;
         $num_not_evaluated_deletion_local     += $evaluate::num_not_evaluated_deletion;
      }
   }
}



#----------------------------------------------------------------------
# evaluate_substitution
#----------------------------------------------------------------------
sub evaluate_substitution {
   if ($in_similarity == 1) {
      my $base1;
      my $base2;

      # $i: 1-based
      for (my $i = 1; $i <= length($_[0]); $i++) {
         # $base1 = $hash_substitution_org{$i}
         $base1 = substr($_[0], $i - 1, 1);

         # character in the modified read
         $base2 = substr($_[2], $i - 1, 1);

         $cor_num_total_bases_percent_similarity_local++;

         if ($base1 eq $base2) {
            $cor_num_matched_bases_percent_similarity_local++;
         }
      }
      # check the number of processed errors
      
      my $count_out = "count.out";
      $ENV{dp_corr_read} = $_[2];
      $ENV{dp_orig_read} = $_[1];
      $ENV{dp_ref_sequence} = $_[0];
      $ENV{dp_count_out} = $count_out;
      #print "\n SUBSTITUTION \n";
      #print "\n Reference \n";
      #print $ENV{dp_ref_sequence};
      #print "\n Orig \n";
      #print $ENV{dp_orig_read};
      #print "\n Corr \n";
      #print $ENV{dp_corr_read};
      #print "\n";
 
      my $cmd1;
      $cmd1 = q{python run.py $dp_ref_sequence $dp_orig_read $dp_corr_read > $dp_count_out };
      system($cmd1);

      open FH_COUNT, "$count_out"
        or die "\nERROR: Cannot open $count_out\n\n";
      #my $cmd2 = q{cat $dp_count_out};
      #system($cmd2);
      my @error_count = (0,0,0,0,0);   
      @error_count = <FH_COUNT>;
      
      close FH_COUNT;
         
      $num_yyns_substitution_local             += $error_count[0];
      $num_ynys_substitution_local             += $error_count[1];
      $num_nyys_substitution_local             += $error_count[2];
      $num_nyns_substitution_local             += $error_count[3];
      $num_nnns_substitution_local             += $error_count[4];  
   }
   else {
      my $base1;
      my $base2;

      # $i: 1-based
      for (my $i = 1; $i <= length($_[0]); $i++) {
         # character in the reference sequence
         # $base1 = $hash_substitution_org{$i}
         $base1 = substr($_[0], $i - 1, 1);

         # character in the modified read
         $base2 = substr($_[2], $i - 1, 1);

         # $hash_substitution_err{$i} = character in the original read

         # error in the original read (nXX)
         if (defined($hash_substitution_err{$i})) {
            # correctly modified
            if ($base1 eq $base2) {
               $num_nyys_substitution_local++;

               # update @position_array*
               evaluate::intp_setitem($position_vector_local,           $i, evaluate::intp_getitem($position_vector_local,           $i) + 1);
               evaluate::intp_setitem($corrected_position_vector_local, $i, evaluate::intp_getitem($corrected_position_vector_local, $i) + 1);

               if (defined($in_detail_prefix)) {
                  my $current_index;
                  my $org_base;
                  my $err_base;

                  # calculate the index of the error in the reference sequence
                  if ($strand eq "+") {
                     # both $start_index and $i are 1-based
                     $current_index = $start_index + $i - 1;

                     $org_base = $hash_substitution_org{$i};
                     $err_base = $hash_substitution_err{$i};
                  }
                  elsif ($strand eq "-") {
                     # both $end_index and $i are 1-based
                     $current_index = $end_index - $i + 1;

                     $org_base = $hash_complement{$hash_substitution_org{$i}};
                     $err_base = $hash_complement{$hash_substitution_err{$i}};
                  }
                  else {
                     die "\nERROR: Illegal strand $strand\n\n";
                  }

                  if ($ref_1_or_2 == 1) {
                     print $fh_error_index1 "$hash_ref_name_to_index_1{$seq_name} $current_index $org_base $err_base Y CASE02 $read_name $start_index $end_index\n";
                  }
                  elsif ($ref_1_or_2 == 2) {
                     print $fh_error_index2 "$hash_ref_name_to_index_2{$seq_name} $current_index $org_base $err_base Y CASE02 $read_name $start_index $end_index\n";
                  }
                  else {
                     die "\nERROR: Illegal reference identifier $ref_1_or_2\n\n";
                  }
               }
            }
            # not correctly modified
            else {
               # not modified
               if ($base2 eq $hash_substitution_err{$i}) {
                  $num_nnns_substitution_local++;

                  # update @position_array*
                  evaluate::intp_setitem($position_vector_local, $i, evaluate::intp_getitem($position_vector_local, $i) + 1);

                  if (defined($in_detail_prefix)) {
                     my $current_index;
                     my $org_base;
                     my $err_base;

                     # calculate the index of the error in the reference sequence
                     if ($strand eq "+") {
                        # both $start_index and $i are 1-based
                        $current_index = $start_index + $i - 1;

                        $org_base = $hash_substitution_org{$i};
                        $err_base = $hash_substitution_err{$i};
                     }
                     elsif ($strand eq "-") {
                        # both $end_index and $i are 1-based
                        $current_index = $end_index - $i + 1;

                        $org_base = $hash_complement{$hash_substitution_org{$i}};
                        $err_base = $hash_complement{$hash_substitution_err{$i}};
                     }
                     else {
                        die "\nERROR: Illegal strand $strand\n\n";
                     }

                     if ($ref_1_or_2 == 1) {
                        print $fh_error_index1 "$hash_ref_name_to_index_1{$seq_name} $current_index $org_base $err_base N CASE03 $read_name $start_index $end_index\n";
                     }
                     elsif ($ref_1_or_2 == 2) {
                        print $fh_error_index2 "$hash_ref_name_to_index_2{$seq_name} $current_index $org_base $err_base N CASE03 $read_name $start_index $end_index\n";
                     }
                     else {
                        die "\nERROR: Illegal reference identifier $ref_1_or_2\n\n";
                     }
                  }
               }
               # modified but the result is wrong
               else {
                  $num_nyns_substitution_local++;

                  # update @position_array*
                  evaluate::intp_setitem($position_vector_local, $i, evaluate::intp_getitem($position_vector_local, $i) + 1);

                  if (defined($in_detail_prefix)) {
                     my $current_index;
                     my $org_base;
                     my $err_base;

                     # calculate the index of the error in the reference sequence
                     if ($strand eq "+") {
                        # both $start_index and $i are 1-based
                        $current_index = $start_index + $i - 1;

                        $org_base = $hash_substitution_org{$i};
                        $err_base = $hash_substitution_err{$i};
                     }
                     elsif ($strand eq "-") {
                        # both $end_index and $i are 1-based
                        $current_index = $end_index - $i + 1;

                        $org_base = $hash_complement{$hash_substitution_org{$i}};
                        $err_base = $hash_complement{$hash_substitution_err{$i}};
                     }
                     else {
                        die "\nERROR: Illegal strand $strand\n\n";
                     }

                     if ($ref_1_or_2 == 1) {
                        print $fh_error_index1 "$hash_ref_name_to_index_1{$seq_name} $current_index $org_base $err_base N CASE04 $read_name $start_index $end_index\n";
                     }
                     elsif ($ref_1_or_2 == 2) {
                        print $fh_error_index2 "$hash_ref_name_to_index_2{$seq_name} $current_index $org_base $err_base N CASE04 $read_name $start_index $end_index\n";
                     }
                     else {
                        die "\nERROR: Illegal reference identifier $ref_1_or_2\n\n";
                     }
                  }
               }
            }
         }
         # no error in the original read (yXX)
         else {
            if ($base1 eq $base2) {
               $num_ynys_substitution_local++;
            }
            else {
               $num_yyns_substitution_local++;
            }
         }
      }
   }
}



#----------------------------------------------------------------------
# check_sequence
#----------------------------------------------------------------------
sub check_sequence {
  my ($seq) = @_;

  $seq = uc $seq;

  my $seq_tmp = $seq;

  # characters in $alphabets
  $seq_tmp =~ tr/ACGT//d;

   if ($seq_tmp ne "") {
      die "\nERROR: Illegal characters exist $seq\n\n";
   }
   elsif (length($seq) > $max_seq_length) {
      die "\nERROR: The sequence is too long $seq\n\n";
   }

   return $seq;
}



#----------------------------------------------------------------------
# run_mpileup
#----------------------------------------------------------------------
sub run_mpileup {
   # check the number of arguments
   my $num_arguments = 4;
   my $function_name = "run_mpileup";

   my ($ref_1_or_2_local, $ref_seq_name, $mpileup_start_index, $mpileup_end_index) = @_;

   $ENV{evaluate_dna_samtools} = $samtools;
   $ENV{evaluate_dna_mpileup}  = $mpileup_file;
   $ENV{evaluate_dna_ref_seq}  = $ref_seq_name;
   $ENV{evaluate_dna_start}    = $mpileup_start_index;
   $ENV{evaluate_dna_end}      = $mpileup_end_index;

   if ($ref_1_or_2_local == 1) {
      $ENV{evaluate_dna_ref} = $in_ref1_file;
      $ENV{evaluate_dna_bam} = $in_bam1_file;
   }
   elsif ($ref_1_or_2_local == 2) {
      $ENV{evaluate_dna_ref} = $in_ref2_file;
      $ENV{evaluate_dna_bam} = $in_bam2_file;
   }
   else {
      die "\nERROR: Illegal reference identifier $ref_1_or_2\n\n";
   }

   my $cmd;

   $cmd = q{$evaluate_dna_samtools mpileup -f $evaluate_dna_ref -Q 0 -r "${evaluate_dna_ref_seq}:${evaluate_dna_start}-${evaluate_dna_end}" $evaluate_dna_bam > $evaluate_dna_mpileup};
   system($cmd);
}



#----------------------------------------------------------------------
# update_histograms
#----------------------------------------------------------------------
sub update_histograms {
   # check the number of arguments
   my $num_arguments = 6;
   my $function_name = "update_histograms";

   # 1st: 1st or 2nd reference?
   # 2nd: chromosome index
   # 3rd: erroneous base
   # 4th: mpileup string
   # 5th: error is corrected?
   # 6th: error index in the reference
   my ($ref_1_or_2_local, $chr_index_local, $err_base_local, $mpileup_string_local, $corrected_local, $err_index_local) = @_;

   my $num_org_base =()= $mpileup_string_local =~ /[.,]/g;
   my $num_err_base =()= $mpileup_string_local =~ /$err_base_local/gi;

   #--------------------------------------------------
   # update the histograms
   #--------------------------------------------------
   # difference
   my $num_diff = $num_org_base - $num_err_base;

   if ($num_diff >= 0) {
      if ($num_diff >= $in_max_depth) {
         $array_num_diff_err_cor[$in_max_depth]++;

         if ($corrected_local eq "Y") {
            $array_num_diff_err_cor_corrected[$in_max_depth]++;
         }
      }
      else {
         $array_num_diff_err_cor[$num_diff]++;

         if ($corrected_local eq "Y") {
            $array_num_diff_err_cor_corrected[$num_diff]++;
         }
      }
   }
   else {
      $num_diff = -$num_diff;

      if ($num_diff >= $in_max_depth) {
         $array_num_diff_err_cor_neg[$in_max_depth]++;

         if ($corrected_local eq "Y") {
            $array_num_diff_err_cor_corrected_neg[$in_max_depth]++;
         }
      }
      else {
         $array_num_diff_err_cor_neg[$num_diff]++;

         if ($corrected_local eq "Y") {
            $array_num_diff_err_cor_corrected_neg[$num_diff]++;
         }
      }
   }

   # coverage
   if ($num_org_base >= $in_max_depth) {
      $array_coverage[$in_max_depth]++;

      if ($corrected_local eq "Y") {
         $array_coverage_corrected[$in_max_depth]++;
      }
   }
   else {
      $array_coverage[$num_org_base]++;

      if ($corrected_local eq "Y") {
         $array_coverage_corrected[$num_org_base]++;
      }
   }
}



#----------------------------------------------------------------------
# calculate_average_read_length
#----------------------------------------------------------------------
sub calculate_average_read_length {
   my $read_length;
   my $array_index;
   my $partial_sum;

   my @read_length_list;

   #----------------------------------------------------------------------
   # original reads
   #----------------------------------------------------------------------
   my $fh_org_read1;
   my $fh_org_read2;

   # open original read files
   if ($is_paired) {
      if ($org_fastq_input == 1) {
         if ($in_org_fastq1_file =~ /\.gz$/) {
            $fh_org_read1 = IO::Uncompress::Gunzip->new($in_org_fastq1_file)
               or die "\nERROR: Cannot open $in_org_fastq1_file\n\n"
         }
         else {
            open $fh_org_read1, "$in_org_fastq1_file"
               or die "\nERROR: Cannot open $in_org_fastq1_file\n\n";
         }

         if ($in_org_fastq2_file =~ /\.gz$/) {
            $fh_org_read2 = IO::Uncompress::Gunzip->new($in_org_fastq2_file)
               or die "\nERROR: Cannot open $in_org_fastq2_file\n\n"
         }
         else {
            open $fh_org_read2, "$in_org_fastq2_file"
               or die "\nERROR: Cannot open $in_org_fastq2_file\n\n";
         }
      }
      else {
         if ($in_org_fasta1_file =~ /\.gz$/) {
            $fh_org_read1 = IO::Uncompress::Gunzip->new($in_org_fasta1_file)
               or die "\nERROR: Cannot open $in_org_fasta1_file\n\n"
         }
         else {
            open $fh_org_read1, "$in_org_fasta1_file"
               or die "\nERROR: Cannot open $in_org_fasta1_file\n\n";
         }

         if ($in_org_fasta2_file =~ /\.gz$/) {
            $fh_org_read2 = IO::Uncompress::Gunzip->new($in_org_fasta2_file)
               or die "\nERROR: Cannot open $in_org_fasta2_file\n\n"
         }
         else {
            open $fh_org_read2, "$in_org_fasta2_file"
               or die "\nERROR: Cannot open $in_org_fasta2_file\n\n";
         }
      }
   }
   else {
      if ($org_fastq_input == 1) {
         if ($in_org_fastq_file =~ /\.gz$/) {
            $fh_org_read1 = IO::Uncompress::Gunzip->new($in_org_fastq_file)
               or die "\nERROR: Cannot open $in_org_fastq_file\n\n"
         }
         else {
            open $fh_org_read1, "$in_org_fastq_file"
               or die "\nERROR: Cannot open $in_org_fastq_file\n\n";
         }
      }
      else {
         if ($in_org_fasta_file =~ /\.gz$/) {
            $fh_org_read1 = IO::Uncompress::Gunzip->new($in_org_fasta_file)
               or die "\nERROR: Cannot open $in_org_fasta_file\n\n"
         }
         else {
            open $fh_org_read1, "$in_org_fasta_file"
               or die "\nERROR: Cannot open $in_org_fasta_file\n\n";
         }
      }
   }

   # initialize the read length array size
   for (my $it_array = 0; $it_array < ($read_length_array_size + 1); $it_array++) {
      $org_read_length_distribution_array[$it_array] = 0;
   }

   $org_total_read_length = 0;
   $org_num_reads         = 0;

   @read_length_list = ();

   # iterate each line
   # 1st file
   while (my $line = <$fh_org_read1>) {
      # get the sequence length
      $line = <$fh_org_read1>;
      chomp $line;
      $read_length = length($line);

      # update values
      $org_total_read_length += $read_length;
      $org_num_reads++;

      {
         use integer;
         $array_index = $read_length / 1000;
      }
      if ($array_index >= $read_length_array_size) {
         $org_read_length_distribution_array[$read_length_array_size]++;
      }
      else {
         $org_read_length_distribution_array[$array_index]++;
      }

      # if the read is longer than the threshold
      # add the read to the list
      if ($read_length >= $ng_cutoff) {
         push (@read_length_list, $read_length);
      }

      # skip the remaining lines of the fastq format
      if ($org_fastq_input == 1) {
         $line = <$fh_org_read1>;
         $line = <$fh_org_read1>;
      }
   }

   # 2nd file
   if ($is_paired) {
      while (my $line = <$fh_org_read2>) {
         # get the sequence length
         $line = <$fh_org_read2>;
         chomp $line;
         $read_length = length($line);

         # update values
         $org_total_read_length += $read_length;
         $org_num_reads++;

         {
            use integer;
            $array_index = $read_length / 1000;
         }
         if ($array_index >= $read_length_array_size) {
            $org_read_length_distribution_array[$read_length_array_size]++;
         }
         else {
            $org_read_length_distribution_array[$array_index]++;
         }

         # if the read is longer than the threshold
         # add the read to the list
         if ($read_length >= $ng_cutoff) {
            push (@read_length_list, $read_length);
         }

         # skip the remaining lines of the fastq format
         if ($org_fastq_input == 1) {
            $line = <$fh_org_read2>;
            $line = <$fh_org_read2>;
         }
      }
   }

   # get the total reference sequence length
#   $total_ref_length1 = 0;
#   $total_ref_length2 = 0;

#   foreach my $each_key (keys %hash_ref_1) {
#      $total_ref_length1 += length($hash_ref_1{$each_key});
#   }
#
#   if ($two_references == 1) {
#      foreach my $each_key (keys %hash_ref_2) {
#         $total_ref_length2 += length($hash_ref_2{$each_key});
#      }
#   }

   # get ngx0 values for ref1
   $partial_sum = 0;
   $org_ng10_ref1   = -1;
   $org_ng30_ref1   = -1;
   $org_ng50_ref1   = -1;
   $org_ng70_ref1   = -1;
   $org_ng90_ref1   = -1;

   foreach my $each_length (sort {$b <=> $a} @read_length_list) {
      $partial_sum += $each_length;

      if ($org_ng10_ref1 == -1) {
         if ($partial_sum >= ($total_ref_length1 * 0.1)) {
            $org_ng10_ref1 = $each_length;
         }
      }
      if ($org_ng30_ref1 == -1) {
         if ($partial_sum >= ($total_ref_length1 * 0.3)) {
            $org_ng30_ref1 = $each_length;
         }
      }
      if ($org_ng50_ref1 == -1) {
         if ($partial_sum >= ($total_ref_length1 * 0.5)) {
            $org_ng50_ref1 = $each_length;
         }
      }
      if ($org_ng70_ref1 == -1) {
         if ($partial_sum >= ($total_ref_length1 * 0.7)) {
            $org_ng70_ref1 = $each_length;
         }
      }
      if ($org_ng90_ref1 == -1) {
         if ($partial_sum >= ($total_ref_length1 * 0.9)) {
            $org_ng90_ref1 = $each_length;
         }
      }
   }

   # get ngx0 values for ref1
   if ($two_references == 1) {
      $partial_sum = 0;
      $org_ng10_ref2   = -1;
      $org_ng30_ref2   = -1;
      $org_ng50_ref2   = -1;
      $org_ng70_ref2   = -1;
      $org_ng90_ref2   = -1;

      foreach my $each_length (sort {$b <=> $a} @read_length_list) {
         $partial_sum += $each_length;

         if ($org_ng10_ref2 == -1) {
            if ($partial_sum >= ($total_ref_length2 * 0.1)) {
               $org_ng10_ref2 = $each_length;
            }
         }
         if ($org_ng30_ref2 == -1) {
            if ($partial_sum >= ($total_ref_length2 * 0.3)) {
               $org_ng30_ref2 = $each_length;
            }
         }
         if ($org_ng50_ref2 == -1) {
            if ($partial_sum >= ($total_ref_length2 * 0.5)) {
               $org_ng50_ref2 = $each_length;
            }
         }
         if ($org_ng70_ref2 == -1) {
            if ($partial_sum >= ($total_ref_length2 * 0.7)) {
               $org_ng70_ref2 = $each_length;
            }
         }
         if ($org_ng90_ref2 == -1) {
            if ($partial_sum >= ($total_ref_length2 * 0.9)) {
               $org_ng90_ref2 = $each_length;
            }
         }
      }
   }

   # close origina read files
   close $fh_org_read1;

   if ($is_paired) {
      close $fh_org_read2;
   }

   #----------------------------------------------------------------------
   # corrected reads
   #----------------------------------------------------------------------
   my $fh_cor_read1;
   my $fh_cor_read2;

   # open corrected read files
   if ($is_paired) {
      if ($cor_fastq_input == 1) {
         if ($in_cor_fastq1_file =~ /\.gz$/) {
            $fh_cor_read1 = IO::Uncompress::Gunzip->new($in_cor_fastq1_file)
               or die "\nERROR: Cannot open $in_cor_fastq1_file\n\n"
         }
         else {
            open $fh_cor_read1, "$in_cor_fastq1_file"
               or die "\nERROR: Cannot open $in_cor_fastq1_file\n\n";
         }

         if ($in_cor_fastq2_file =~ /\.gz$/) {
            $fh_cor_read2 = IO::Uncompress::Gunzip->new($in_cor_fastq2_file)
               or die "\nERROR: Cannot open $in_cor_fastq2_file\n\n"
         }
         else {
            open $fh_cor_read2, "$in_cor_fastq2_file"
               or die "\nERROR: Cannot open $in_cor_fastq2_file\n\n";
         }
      }
      else {
         if ($in_cor_fasta1_file =~ /\.gz$/) {
            $fh_cor_read1 = IO::Uncompress::Gunzip->new($in_cor_fasta1_file)
               or die "\nERROR: Cannot open $in_cor_fasta1_file\n\n"
         }
         else {
            open $fh_cor_read1, "$in_cor_fasta1_file"
               or die "\nERROR: Cannot open $in_cor_fasta1_file\n\n";
         }

         if ($in_cor_fasta2_file =~ /\.gz$/) {
            $fh_cor_read2 = IO::Uncompress::Gunzip->new($in_cor_fasta2_file)
               or die "\nERROR: Cannot open $in_cor_fasta2_file\n\n"
         }
         else {
            open $fh_cor_read2, "$in_cor_fasta2_file"
               or die "\nERROR: Cannot open $in_cor_fasta2_file\n\n";
         }
      }
   }
   else {
      if ($cor_fastq_input == 1) {
         if ($in_cor_fastq_file =~ /\.gz$/) {
            $fh_cor_read1 = IO::Uncompress::Gunzip->new($in_cor_fastq_file)
               or die "\nERROR: Cannot open $in_cor_fastq_file\n\n"
         }
         else {
            open $fh_cor_read1, "$in_cor_fastq_file"
               or die "\nERROR: Cannot open $in_cor_fastq_file\n\n";
         }
      }
      else {
         if ($in_cor_fasta_file =~ /\.gz$/) {
            $fh_cor_read1 = IO::Uncompress::Gunzip->new($in_cor_fasta_file)
               or die "\nERROR: Cannot open $in_cor_fasta_file\n\n"
         }
         else {
            open $fh_cor_read1, "$in_cor_fasta_file"
               or die "\nERROR: Cannot open $in_cor_fasta_file\n\n";
         }
      }
   }

   # initialize the read length array size
   for (my $it_array = 0; $it_array < ($read_length_array_size + 1); $it_array++) {
      $cor_read_length_distribution_array[$it_array] = 0;
   }

   $cor_total_read_length = 0;
   $cor_num_reads         = 0;

   @read_length_list = ();

   # iterate each line
   # 1st file
   while (my $line = <$fh_cor_read1>) {
      # get the sequence length
      $line = <$fh_cor_read1>;
      chomp $line;
      $read_length = length($line);

      # update values
      $cor_total_read_length += $read_length;
      $cor_num_reads++;

      {
         use integer;
         $array_index = $read_length / 1000;
      }
      if ($array_index >= $read_length_array_size) {
         $cor_read_length_distribution_array[$read_length_array_size]++;
      }
      else {
         $cor_read_length_distribution_array[$array_index]++;
      }

      # if the read is longer than the threshold
      # add the read to the list
      if ($read_length >= $ng_cutoff) {
         push (@read_length_list, $read_length);
      }

      # skip the remaining lines of the fastq format
      if ($cor_fastq_input == 1) {
         $line = <$fh_cor_read1>;
         $line = <$fh_cor_read1>;
      }
   }

   # 2nd file
   if ($is_paired) {
      while (my $line = <$fh_cor_read2>) {
         # get the sequence length
         $line = <$fh_cor_read2>;
         chomp $line;
         $read_length = length($line);

         # update values
         $cor_total_read_length += $read_length;
         $cor_num_reads++;

         {
            use integer;
            $array_index = $read_length / 1000;
         }
         if ($array_index >= $read_length_array_size) {
            $cor_read_length_distribution_array[$read_length_array_size]++;
         }
         else {
            $cor_read_length_distribution_array[$array_index]++;
         }

         # if the read is longer than the threshold
         # add the read to the list
         if ($read_length >= $ng_cutoff) {
            push (@read_length_list, $read_length);
         }

         # skip the remaining lines of the fastq format
         if ($cor_fastq_input == 1) {
            $line = <$fh_cor_read2>;
            $line = <$fh_cor_read2>;
         }
      }
   }

#   $total_ref_length1 = 0;
#   $total_ref_length2 = 0;
#
#   foreach my $each_key (keys %hash_ref_1) {
#      $total_ref_length1 += length($hash_ref_1{$each_key});
#   }
#
#   if ($two_references == 1) {
#      foreach my $each_key (keys %hash_ref_2) {
#         $total_ref_length2 += length($hash_ref_2{$each_key});
#      }
#   }

   # get ngx0 values for ref1
   $partial_sum = 0;
   $cor_ng10_ref1   = -1;
   $cor_ng30_ref1   = -1;
   $cor_ng50_ref1   = -1;
   $cor_ng70_ref1   = -1;
   $cor_ng90_ref1   = -1;

   foreach my $each_length (sort {$b <=> $a} @read_length_list) {
      $partial_sum += $each_length;

      if ($cor_ng10_ref1 == -1) {
         if ($partial_sum >= ($total_ref_length1 * 0.1)) {
            $cor_ng10_ref1 = $each_length;
         }
      }
      if ($cor_ng30_ref1 == -1) {
         if ($partial_sum >= ($total_ref_length1 * 0.3)) {
            $cor_ng30_ref1 = $each_length;
         }
      }
      if ($cor_ng50_ref1 == -1) {
         if ($partial_sum >= ($total_ref_length1 * 0.5)) {
            $cor_ng50_ref1 = $each_length;
         }
      }
      if ($cor_ng70_ref1 == -1) {
         if ($partial_sum >= ($total_ref_length1 * 0.7)) {
            $cor_ng70_ref1 = $each_length;
         }
      }
      if ($cor_ng90_ref1 == -1) {
         if ($partial_sum >= ($total_ref_length1 * 0.9)) {
            $cor_ng90_ref1 = $each_length;
         }
      }
   }

   # get ngx0 values for ref1
   if ($two_references == 1) {
      $partial_sum = 0;
      $cor_ng10_ref2   = -1;
      $cor_ng30_ref2   = -1;
      $cor_ng50_ref2   = -1;
      $cor_ng70_ref2   = -1;
      $cor_ng90_ref2   = -1;

      foreach my $each_length (sort {$b <=> $a} @read_length_list) {
         $partial_sum += $each_length;

         if ($cor_ng10_ref2 == -1) {
            if ($partial_sum >= ($total_ref_length2 * 0.1)) {
               $cor_ng10_ref2 = $each_length;
            }
         }
         if ($cor_ng30_ref2 == -1) {
            if ($partial_sum >= ($total_ref_length2 * 0.3)) {
               $cor_ng30_ref2 = $each_length;
            }
         }
         if ($cor_ng50_ref2 == -1) {
            if ($partial_sum >= ($total_ref_length2 * 0.5)) {
               $cor_ng50_ref2 = $each_length;
            }
         }
         if ($cor_ng70_ref2 == -1) {
            if ($partial_sum >= ($total_ref_length2 * 0.7)) {
               $cor_ng70_ref2 = $each_length;
            }
         }
         if ($cor_ng90_ref2 == -1) {
            if ($partial_sum >= ($total_ref_length2 * 0.9)) {
               $cor_ng90_ref2 = $each_length;
            }
         }
      }
   }

   # close origina read files
   close $fh_cor_read1;

   if ($is_paired) {
      close $fh_cor_read2;
   }
}



#----------------------------------------------------------------------
# parse_errors
#----------------------------------------------------------------------
sub parse_errors {
   my ($read_length, $substitution, $insertion, $deletion) = @_;

   $num_substitutions = 0;
   $num_insertions    = 0;
   $num_deletions     = 0;

   #--------------------------------------------------
   # generate a hash table for substitutions
   # 1-based
   # ref  AAA
   # read AAC
   # 3:A->C;
   #--------------------------------------------------
   my %hash_substitution_org_tmp;
   my %hash_substitution_err_tmp;
   %hash_substitution_org = %hash_substitution_org_tmp;
   %hash_substitution_err = %hash_substitution_err_tmp;

   unless ($substitution eq "-") {
      while ($substitution =~ /(\d+):([ACGT])\->([ACGT]);/g) {
         $hash_substitution_org{$1} = $2;
         $hash_substitution_err{$1} = $3;

         $num_substitutions++;
      }
   }

   #--------------------------------------------------
   # generate a hash table for insertions
   # inserted to the right of the index
   # 1-based
   # ex1: 2:AC;
   # ref  AA--
   # read AAAC
   # ex2: 0:AC;
   # ref  --AA
   # read ACAA
   #--------------------------------------------------
   my %hash_insertion_tmp;
   %hash_insertion = %hash_insertion_tmp;

   unless ($insertion eq "-") {
      while ($insertion =~ /(\d+):([ACGT]+);/g) {
         $hash_insertion{$1} = $2;

         $num_insertions = $num_insertions + length $2;
      }
   }

   #--------------------------------------------------
   # generate a hash table for deletions
   # HASH VALUE MIGHT BE WRONG
   # if the information was made using pirs
   # however, it is ok because the values will not be used
   # 3:C;4:G;
   # ref  AACG
   # read AA--
   #--------------------------------------------------
   my %hash_deletion_tmp;
   %hash_deletion = %hash_deletion_tmp;

   unless ($deletion eq "-") {
      while ($deletion =~ /(\d+):([ACGT]);/g) {
         $hash_deletion{$1} = $2;

         $num_deletions++;
      }
   }

   # update the percent similarity information for original reads
   if ($in_similarity == 1) {
      $org_num_total_bases_percent_similarity_local   += ($read_length + $num_deletions);
      $org_num_matched_bases_percent_similarity_local += ($read_length - $num_substitutions - $num_insertions);
   }
}



#----------------------------------------------------------------------
# read_ref_chromosome
#----------------------------------------------------------------------
sub read_ref_chromosome {
   # arguemnts
   # 1st($_[0]): $in_ref[12]_file
   # 3rd($_[1]): $seq_name
   # 4th($_[2]): %hash_ref_[12]

   # open files
   my $fh_in;
   open $fh_in, "$_[0]"
      or die "\nERROR: Cannot open $_[0]\n\n";

   # load a new chromosome
   my $buffer = "";
   my $flag   = 0;

   while (my $line = <$fh_in>) {
      chomp $line;

      if ($line =~ /^>(\S+)/) {
         # target chromosome
         if ($_[1] eq $1) {
            if ($flag == 1) {
               die "\nERROR: Two chromosomes with the same name $_[1]\n\n";
            }

            $flag = 1;
         }
         # non-target chromosome
         else {
            if ($flag == 1) {
               $_[2]{$_[1]} = $buffer;

               $flag   = 0;
               $buffer = "";
               last;
            }
         }
      }
      elsif ($line =~ /^$/) {
      }
      else {
         if ($flag == 1) {
            $line = uc $line;
            $buffer = $buffer . $line;
         }
      }
   }

   # the target chromosome is the last one
   if (length($buffer) > 0) {
      if ($flag == 1) {
         $_[2]{$_[1]} = $buffer;
      }
      else {
         die "\nERROR: Wrong fasta file\n\n";
      }
   }

   close $fh_in;
}
